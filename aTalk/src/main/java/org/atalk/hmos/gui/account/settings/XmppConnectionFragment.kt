/*
 * Jitsi, the OpenSource Java VoIP and Instant Messaging client.
 *
 * Distributable under LGPL license. See terms of license at gnu.org.
 */
package org.atalk.hmos.gui.account.settings

import android.content.SharedPreferences
import android.content.SharedPreferences.*
import android.os.Bundle
import androidx.preference.ListPreference
import androidx.preference.Preference
import net.java.sip.communicator.impl.protocol.jabber.ProtocolProviderServiceJabberImpl
import net.java.sip.communicator.plugin.jabberaccregwizz.JabberAccountRegistrationActivator
import net.java.sip.communicator.service.certificate.CertificateConfigEntry
import net.java.sip.communicator.service.certificate.CertificateService
import net.java.sip.communicator.service.protocol.AccountID
import net.java.sip.communicator.service.protocol.ProtocolProviderService
import net.java.sip.communicator.service.protocol.jabber.JabberAccountRegistration
import net.java.sip.communicator.util.account.AccountUtils
import org.atalk.hmos.R
import org.atalk.hmos.gui.settings.util.SummaryMapper
import org.atalk.hmos.gui.settings.util.SummaryMapper.SummaryConverter
import org.atalk.service.osgi.OSGiPreferenceFragment
import timber.log.Timber
import java.io.IOException
import javax.net.ssl.SSLSocket
import javax.net.ssl.SSLSocketFactory

/**
 * The preferences fragment implements for xmpp connection settings.
 *
 * @author Eng Chong Meng
 */
open class XmppConnectionFragment : OSGiPreferenceFragment(), OnSharedPreferenceChangeListener {
    lateinit var shPrefs: SharedPreferences

    /**
     * We load values only once into shared preferences to not reset values on screen rotated event.
     */
    private val isInitialized = false

    /**
     * Summary mapper used to display preferences values as summaries.
     */
    private val summaryMapper = SummaryMapper()

    /**
     * {@inheritDoc}
     */
    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
        setPreferencesFromResource(R.xml.xmpp_connection_preferences, rootKey)
        setPrefTitle(R.string.service_gui_JBR_CONNECTION)
        val accountID = arguments!!.getString(AccountPreferenceFragment.EXTRA_ACCOUNT_ID)
        val account = AccountUtils.getAccountIDForUID(accountID!!)
        val pps = AccountUtils.getRegisteredProviderForAccount(account)
        if (pps == null) {
            Timber.w("No protocol provider registered for %s", account)
            return
        }
        jbrReg = JabberPreferenceFragment.jbrReg
        shPrefs = preferenceManager.sharedPreferences!!
        shPrefs.registerOnSharedPreferenceChangeListener(this)
        shPrefs.registerOnSharedPreferenceChangeListener(summaryMapper)
        initPreferences()
        initTLSCert(pps.accountID)
        mapSummaries(summaryMapper)
    }

    private fun initPreferences() {
        val editor = shPrefs.edit()

        // Connection
        editor.putBoolean(P_KEY_GMAIL_NOTIFICATIONS, jbrReg.isGmailNotificationEnabled())
        editor.putBoolean(P_KEY_GOOGLE_CONTACTS_ENABLED, jbrReg.isGoogleContactsEnabled())
        editor.putString(P_KEY_MINIMUM_TLS_VERSION, jbrReg.getMinimumTLSversion())
        editor.putBoolean(P_KEY_ALLOW_NON_SECURE_CONN, jbrReg.isAllowNonSecure())
        editor.putString(P_KEY_DTMF_METHOD, jbrReg.dtmfMethod)

        // Keep alive options
        editor.putBoolean(P_KEY_IS_KEEP_ALIVE_ENABLE, jbrReg.isKeepAliveEnable)
        editor.putString(P_KEY_PING_INTERVAL, jbrReg.pingInterval)
        editor.putBoolean(P_KEY_IS_PING_AUTO_TUNE_ENABLE, jbrReg.isPingAutoTuneEnable)
        editor.putString(P_KEY_TLS_CERT_ID, jbrReg.tlsClientCertificate)

        // Server options
        editor.putBoolean(P_KEY_IS_SERVER_OVERRIDDEN, jbrReg.isServerOverridden)
        editor.putString(P_KEY_SERVER_ADDRESS, jbrReg.serverAddress)
        editor.putString(P_KEY_SERVER_PORT, jbrReg.serverPort)

        // Resource
        editor.putBoolean(P_KEY_AUTO_GEN_RESOURCE, jbrReg.isResourceAutoGenerated())
        editor.putString(P_KEY_RESOURCE_NAME, jbrReg.getResource())
        editor.putString(P_KEY_RESOURCE_PRIORITY, "" + jbrReg.getPriority())
        editor.apply()
    }

    /**
     * Initialize the client TLS certificate selection list
     */
    private fun initTLSCert(accountID: AccountID) {
        val certList = ArrayList<String>()
        val cvs = JabberAccountRegistrationActivator.certificateService
        val certEntries = cvs.getClientAuthCertificateConfigs()
        certEntries.add(0, CertificateConfigEntry.CERT_NONE)
        for (e in certEntries) {
            certList.add(e.toString())
        }
        var currentCert = accountID.tlsClientCertificate
        if (!certList.contains(currentCert) && !isInitialized) {
            // Use the empty one i.e. None cert
            currentCert = certList[0]
            preferenceManager.sharedPreferences!!.edit().putString(P_KEY_TLS_CERT_ID, currentCert).apply()
        }
        var entries = arrayOfNulls<String>(certList.size)
        entries = certList.toArray(entries)
        val certPreference = findPreference<ListPreference>(P_KEY_TLS_CERT_ID)!!
        certPreference.entries = entries
        certPreference.entryValues = entries
        if (!isInitialized) certPreference.value = currentCert
    }

    /**
     * {@inheritDoc}
     */
    private fun mapSummaries(summaryMapper: SummaryMapper) {
        val emptyStr = getString(R.string.service_gui_SETTINGS_NOT_SET)

        // DTMF Option
        summaryMapper.includePreference(findPreference(P_KEY_DTMF_METHOD), emptyStr, object : SummaryConverter {
            override fun convertToSummary(input: String?): String {
                val lp = findPreference<ListPreference>(P_KEY_DTMF_METHOD)
                return lp!!.entry.toString()
            }
        })

        // Ping interval
        summaryMapper.includePreference(findPreference(P_KEY_PING_INTERVAL), emptyStr)
        summaryMapper.includePreference(findPreference(P_KEY_TLS_CERT_ID), emptyStr)

        // Server options
        summaryMapper.includePreference(findPreference(P_KEY_SERVER_ADDRESS), emptyStr)
        summaryMapper.includePreference(findPreference(P_KEY_SERVER_PORT), emptyStr)

        // Resource
        summaryMapper.includePreference(findPreference(P_KEY_RESOURCE_NAME), emptyStr)
        summaryMapper.includePreference(findPreference(P_KEY_RESOURCE_PRIORITY), emptyStr)
    }

    /**
     * {@inheritDoc}
     */
    override fun onSharedPreferenceChanged(shPreferences: SharedPreferences, key: String) {
        // Check to ensure a valid key before proceed
        if (findPreference<Preference>(key) == null) return
        AccountPreferenceFragment.uncommittedChanges = true
        if (key == P_KEY_GMAIL_NOTIFICATIONS) {
            jbrReg.setGmailNotificationEnabled(shPrefs.getBoolean(P_KEY_GMAIL_NOTIFICATIONS, false))
        } else if (key == P_KEY_GOOGLE_CONTACTS_ENABLED) {
            jbrReg.setGoogleContactsEnabled(shPrefs.getBoolean(P_KEY_GOOGLE_CONTACTS_ENABLED, false))
        } else if (key == P_KEY_MINIMUM_TLS_VERSION) {
            var newMinimumTLSVersion = shPrefs.getString(P_KEY_MINIMUM_TLS_VERSION,
                    ProtocolProviderServiceJabberImpl.defaultMinimumTLSversion)
            var isSupported = false
            try {
                val supportedProtocols = (SSLSocketFactory.getDefault().createSocket() as SSLSocket).supportedProtocols
                for (suppProto in supportedProtocols) {
                    if (suppProto == newMinimumTLSVersion) {
                        isSupported = true
                        break
                    }
                }
            } catch (ignore: IOException) {
            }
            if (!isSupported) {
                newMinimumTLSVersion = ProtocolProviderServiceJabberImpl.defaultMinimumTLSversion
            }
            jbrReg.setMinimumTLSversion(newMinimumTLSVersion!!)
        } else if (key == P_KEY_ALLOW_NON_SECURE_CONN) {
            jbrReg.setAllowNonSecure(shPrefs.getBoolean(P_KEY_ALLOW_NON_SECURE_CONN, false))
        } else if (key == P_KEY_DTMF_METHOD) {
            jbrReg.dtmfMethod = shPrefs.getString(P_KEY_DTMF_METHOD, null)
        } else if (key == P_KEY_IS_KEEP_ALIVE_ENABLE) {
            jbrReg.setKeepAliveOption(shPrefs.getBoolean(P_KEY_IS_KEEP_ALIVE_ENABLE, true))
        } else if (key == P_KEY_PING_INTERVAL) {
            jbrReg.pingInterval = shPrefs.getString(P_KEY_PING_INTERVAL,
                    Integer.toString(ProtocolProviderServiceJabberImpl.defaultPingInterval))
        } else if (key == P_KEY_IS_PING_AUTO_TUNE_ENABLE) {
            jbrReg.setPingAutoTuneOption(shPrefs.getBoolean(P_KEY_IS_PING_AUTO_TUNE_ENABLE, true))
        } else if (key == P_KEY_TLS_CERT_ID) {
            jbrReg.tlsClientCertificate = shPrefs.getString(P_KEY_TLS_CERT_ID, null)
        } else if (key == P_KEY_IS_SERVER_OVERRIDDEN) {
            jbrReg.isServerOverridden = shPrefs.getBoolean(P_KEY_IS_SERVER_OVERRIDDEN, false)
        } else if (key == P_KEY_SERVER_ADDRESS) {
            jbrReg.serverAddress = shPrefs.getString(P_KEY_SERVER_ADDRESS, null)
        } else if (key == P_KEY_SERVER_PORT) {
            jbrReg.serverPort = shPrefs.getString(P_KEY_SERVER_PORT,
                    Integer.toString(ProtocolProviderServiceJabberImpl.DEFAULT_PORT))
        } else if (key == P_KEY_AUTO_GEN_RESOURCE) {
            jbrReg.setResourceAutoGenerated(shPrefs.getBoolean(P_KEY_AUTO_GEN_RESOURCE, true))
        } else if (key == P_KEY_RESOURCE_NAME) {
            jbrReg.setResource(shPrefs.getString(P_KEY_RESOURCE_NAME, null)!!)
        } else if (key == P_KEY_RESOURCE_PRIORITY) {
            try {
                jbrReg.setPriority(shPrefs.getInt(P_KEY_RESOURCE_PRIORITY, 30))
            } catch (ex: Exception) {
                Timber.w("Invalid resource priority: %s", ex.message)
            }
        }
    }

    companion object {
        // Account General
        private const val P_KEY_GMAIL_NOTIFICATIONS = "pref_key_gmail_notifications"
        private const val P_KEY_GOOGLE_CONTACTS_ENABLED = "pref_key_google_contact_enabled"
        private const val P_KEY_DTMF_METHOD = "pref_key_dtmf_method"

        // Client TLS certificate
        private const val P_KEY_TLS_CERT_ID = "pref_key_client_tls_cert"

        // Server Options
        private const val P_KEY_IS_KEEP_ALIVE_ENABLE = "pref_key_is_keep_alive_enable"
        const val P_KEY_PING_INTERVAL = "pref_key_ping_interval"
        private const val P_KEY_IS_PING_AUTO_TUNE_ENABLE = "pref_key_ping_auto_tune_enable"
        private const val P_KEY_IS_SERVER_OVERRIDDEN = "pref_key_is_server_overridden"
        const val P_KEY_SERVER_ADDRESS = "pref_key_server_address"
        const val P_KEY_SERVER_PORT = "pref_key_server_port"
        private const val P_KEY_MINIMUM_TLS_VERSION = "pref_key_minimum_TLS_version"
        private const val P_KEY_ALLOW_NON_SECURE_CONN = "pref_key_allow_non_secure_conn"

        // Jabber Resource
        private const val P_KEY_AUTO_GEN_RESOURCE = "pref_key_auto_gen_resource"
        private const val P_KEY_RESOURCE_NAME = "pref_key_resource_name"
        private const val P_KEY_RESOURCE_PRIORITY = "pref_key_resource_priority"

        /*
     * A new instance of AccountID and is not the same as accountID.
     * Defined as static, otherwise it may get clear onActivityResult - on some android devices
     */
        lateinit var jbrReg: JabberAccountRegistration
    }
}