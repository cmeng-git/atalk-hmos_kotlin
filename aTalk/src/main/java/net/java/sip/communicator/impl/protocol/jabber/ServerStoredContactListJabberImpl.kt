/*
 * Jitsi, the OpenSource Java VoIP and Instant Messaging client.
 *
 * Distributable under LGPL license. See terms of license at gnu.org.
 */
package net.java.sip.communicator.impl.protocol.jabber

import android.database.sqlite.SQLiteDatabase
import net.java.sip.communicator.impl.protocol.jabber.OperationSetPersistentPresenceJabberImpl.ContactChangesListener
import net.java.sip.communicator.service.contactlist.MetaContactGroup
import net.java.sip.communicator.service.customavatar.CustomAvatarService
import net.java.sip.communicator.service.protocol.*
import net.java.sip.communicator.service.protocol.ServerStoredDetails.ImageDetail
import net.java.sip.communicator.service.protocol.event.*
import okhttp3.internal.notifyAll
import okhttp3.internal.wait
import org.atalk.hmos.plugin.timberlog.TimberLog
import org.atalk.persistance.DatabaseBackend
import org.jivesoftware.smack.SmackException.*
import org.jivesoftware.smack.XMPPConnection
import org.jivesoftware.smack.XMPPException
import org.jivesoftware.smack.XMPPException.XMPPErrorException
import org.jivesoftware.smack.filter.PresenceTypeFilter
import org.jivesoftware.smack.packet.*
import org.jivesoftware.smack.roster.Roster
import org.jivesoftware.smack.roster.RosterEntry
import org.jivesoftware.smack.roster.RosterGroup
import org.jivesoftware.smack.roster.RosterListener
import org.jivesoftware.smack.roster.packet.RosterPacket.ItemType
import org.jivesoftware.smackx.avatar.AvatarManager
import org.jivesoftware.smackx.avatar.vcardavatar.VCardAvatarManager
import org.jivesoftware.smackx.nick.packet.Nick
import org.jxmpp.jid.BareJid
import org.jxmpp.jid.DomainBareJid
import org.jxmpp.jid.EntityBareJid
import org.jxmpp.jid.Jid
import org.jxmpp.jid.impl.JidCreate
import org.jxmpp.jid.parts.Localpart
import org.jxmpp.stringprep.XmppStringprepException
import org.osgi.framework.ServiceReference
import timber.log.Timber
import java.util.*

/**
 * This class encapsulates the Roster class. Once created, it will register itself as a listener to
 * the encapsulated Roster and modify its local copy of Contacts and ContactGroups every time an
 * event is generated by the underlying framework. The class would also generate corresponding
 * sip-communicator events to all events coming from smack.
 *
 * @author Damian Minkov
 * @author Emil Ivov
 * @author Hristo Terezov
 * @author Eng Chong Meng
 */
class ServerStoredContactListJabberImpl internal constructor(
        /**
         * The operation set that created us and that we could use when dispatching subscription events.
         */
        private val parentOperationSet: OperationSetPersistentPresenceJabberImpl?,
        /**
         * The provider that is on top of us.
         */
        val parentProvider: ProtocolProviderServiceJabberImpl, infoRetriever: InfoRetriever) {
    /**
     * The jabber list that we encapsulate
     */
    private var mRoster: Roster? = null

    /**
     * The root `ContactGroup`. The container for all jabber buddies and groups.
     */
    val rootGroup = RootContactGroupJabberImpl(parentProvider)

    /**
     * Returns a reference to the provider that created us.
     *
     * @return a reference to a ProtocolProviderServiceImpl instance.
     */

    /**
     * For multiple accounts support, RootGroup can be owned by any of pps at instance to add contact
     */
    private var rootGroupPPS: ProtocolProviderService? = null

    /**
     * Listeners that would receive event notifications for changes in group names or other
     * properties, removal or creation of groups.
     */
    private val serverStoredGroupListeners = Vector<ServerStoredGroupListener>()

    /**
     * Thread retrieving images for contacts
     */
    private var imageRetriever: ImageRetriever? = null

    /**
     * Listens for roster changes.
     */
    private var rosterChangeListener: ChangeListener? = null

    /**
     * Retrieve contact information.
     */
    private val infoRetriever: InfoRetriever

    /*
     * Disable info Retrieval on first login even when local cache is empty
     * cmeng: 20190212seems ejabberd will send VCardTempXUpdate with photo attr in <presence/>
     */
    private var infoRetrieveOnStart = false
    /**
     * Returns whether roster is initialized.
     *
     * @return whether roster is initialized.
     */
    /**
     * Whether roster has been requested and dispatched.
     */
    var isRosterInitialized = false
        private set
    /**
     * The lock around isRosterInitialized variable.
     *
     * @return the lock around isRosterInitialized variable.
     */
    /**
     * Lock object for the isRosterInitialized variable.
     */
    val rosterInitLock = Any()

    /**
     * The initial status saved.
     */
    private var initialStatus: PresenceStatus? = null

    /**
     * The initial status message saved.
     */
    private var initialStatusMessage: String? = null
    private var xmppConnection: XMPPConnection? = null

    /**
     * Creates a ServerStoredContactList wrapper for the specified BuddyList.
     *
     * parentOperationSet the operation set that created us and
     * that we could use for dispatching subscription events
     * provider the provider that has instantiated us.
     * infoRetriever retrieve contact information.
     */
    init {
        // We need to init these as early as possible to ensure that the provider and the
        // operationsSet would not be null in the incoming events.
        this.infoRetriever = infoRetriever
    }

    /**
     * Returns the base of the root group i.e. ContactGroup.
     *
     * @return the root ContactGroup for the ContactList
     */
    fun getRootGroup(): ContactGroup {
        return rootGroup
    }

    /**
     * Returns the roster entry associated with the given XMPP address or
     * `null` if the user is not an entry in the roster.
     *
     * @param userJid the XMPP address of the user (e.g. "jsmith@example.com"). The address could be in any
     * valid format (e.g. "domain/resource", "user@domain" or "user@domain/resource").
     * @return the roster entry or `null` if it does not exist.
     */
    fun getRosterEntry(userJid: BareJid?): RosterEntry? {
        return if (mRoster == null || userJid == null) null else mRoster!!.getEntry(userJid)
    }

    /**
     * Returns the roster group with the specified name, or `null` if the group doesn't exist.
     *
     * @param name the name of the group.
     * @return the roster group with the specified name.
     */
    fun getRosterGroup(name: String?): RosterGroup {
        return mRoster!!.getGroup(name)
    }

    /**
     * Registers the specified group listener so that it would receive events on group
     * modification/creation/destruction.
     *
     * @param listener the ServerStoredGroupListener to register for group events
     */
    fun addGroupListener(listener: ServerStoredGroupListener) {
        synchronized(serverStoredGroupListeners) { if (!serverStoredGroupListeners.contains(listener)) serverStoredGroupListeners.add(listener) }
    }

    /**
     * Removes the specified group listener so that it won't receive further events on group
     * modification/creation/destruction.
     *
     * @param listener the ServerStoredGroupListener to unregister
     */
    fun removeGroupListener(listener: ServerStoredGroupListener) {
        synchronized(serverStoredGroupListeners) { serverStoredGroupListeners.remove(listener) }
    }

    /**
     * Creates the corresponding event and notifies all `ServerStoredGroupListener`s that
     * the source group has been removed, changed, renamed or whatever happened to it.
     *
     * @param group the ContactGroup that has been created/modified/removed
     * i.e. RootContactGroupJabberImpl or ContactGroupJabberImpl
     * @param eventID the id of the event to generate.
     */
    private fun fireGroupEvent(group: ContactGroup?, eventID: Int) {
        // bail out if no one's listening
        if (parentOperationSet == null) {
            Timber.d("No presence opSet available. Bailing out.")
            return
        }
        val evt = ServerStoredGroupEvent(group, eventID,
                parentOperationSet.getServerStoredContactListRoot(), parentProvider, parentOperationSet)
        Timber.log(TimberLog.FINER, "Will dispatch the following grp event: %s", evt)
        var listeners: Iterable<ServerStoredGroupListener>
        synchronized(serverStoredGroupListeners) { listeners = ArrayList(serverStoredGroupListeners) }

        /*
         * Sometimes contact statuses are received before the groups and contacts are being
         * created. This is a problem when we don't have already created unresolved contacts.
         * So we will check contact statuses to be sure they are correct.
         */
        if (eventID == ServerStoredGroupEvent.GROUP_CREATED_EVENT) {
            val iter = group!!.contacts()
            while (iter!!.hasNext()) {
                val c = iter.next() as ContactJabberImpl?

                // roster can be null, receiving system messages from server before we are log in
                if (mRoster != null) {
                    parentOperationSet.firePresenceStatusChanged(mRoster!!.getPresence(c!!.contactJid!!.asBareJid()))
                }
            }
        }
        for (listener in listeners) {
            if (eventID == ServerStoredGroupEvent.GROUP_REMOVED_EVENT) listener.groupRemoved(evt) else if (eventID == ServerStoredGroupEvent.GROUP_RENAMED_EVENT) listener.groupNameChanged(evt) else if (eventID == ServerStoredGroupEvent.GROUP_CREATED_EVENT) listener.groupCreated(evt) else if (eventID == ServerStoredGroupEvent.GROUP_RESOLVED_EVENT) listener.groupResolved(evt)
        }
    }

    /**
     * Make the parent persistent presence operation set dispatch a contact removed event.
     *
     * @param parentGroup the group where that the removed contact belonged to.
     * @param contact the contact that was removed.
     */
    fun fireContactRemoved(parentGroup: ContactGroup?, contact: ContactJabberImpl?) {
        // bail out if no one's listening
        if (parentOperationSet == null) {
            Timber.d("No presence opSet available. Bailing out.")
            return
        }
        Timber.log(TimberLog.FINER, "Removing %s from %s", contact!!.address, parentGroup!!.getGroupName())

        // dispatch
        parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_REMOVED)
    }

    /**
     * Make the parent persistent presence operation set dispatch a subscription moved event.
     *
     * @param oldParentGroup the group where the source contact was located before being moved
     * @param newParentGroup the group that the source contact is currently in.
     * @param contact the contact that was added
     */
    private fun fireContactMoved(oldParentGroup: ContactGroup?, newParentGroup: ContactGroup?, contact: ContactJabberImpl) {
        // bail out if no one's listening
        if (parentOperationSet == null) {
            Timber.d("No presence opSet available. Bailing out.")
            return
        }
        // dispatch
        parentOperationSet.fireSubscriptionMovedEvent(contact, oldParentGroup, newParentGroup)
    }

    /**
     * Returns the ContactGroup with the specified name or null if no such group was found.
     *
     * @param groupName_ the name of the group we're looking for.
     * @return a reference to the ContactGroupJabberImpl instance we're looking for or null if no such group was found.
     */
    fun findContactGroup(groupName_: String): ContactGroupJabberImpl? {
        // make sure we ignore any whitespaces
        var groupName = groupName_
        groupName = groupName.trim { it <= ' ' }
        val contactGroups = rootGroup.subgroups()
        while (contactGroups!!.hasNext()) {
            val contactGroup = contactGroups.next() as ContactGroupJabberImpl?
            if (contactGroup!!.getGroupName()!!.trim { it <= ' ' } == groupName) return contactGroup
        }
        return null
    }

    /**
     * Find a group with the specified Copy of Name. Used to track when a group name has changed
     *
     * @param groupName_ String
     * @return a reference to the ContactGroup instance we're looking for or null if no such group was found.
     */
    private fun findContactGroupByNameCopy(groupName_: String): ContactGroupJabberImpl? {
        // make sure we ignore any whitespaces
        var groupName = groupName_
        groupName = groupName.trim { it <= ' ' }
        val contactGroups = rootGroup.subgroups()
        while (contactGroups!!.hasNext()) {
            val contactGroup = contactGroups.next() as ContactGroupJabberImpl?
            if (contactGroup!!.getNameCopy() != null && contactGroup.getNameCopy()!!.trim { it <= ' ' } == groupName) return contactGroup
        }
        return null
    }

    /**
     * Returns the Contact with the specified id or null if no such id was found.
     *
     * @param id the contactJid of the contact to find (BareJid in actual search).
     * @return the `Contact` carrying the specified `screenName` or `null` if
     * no such contact exits.
     */
    fun findContactById(id: Jid?): ContactJabberImpl? {
        if (id == null) return null
        val contactGroups = rootGroup.subgroups()
        var contact: ContactJabberImpl?
        while (contactGroups!!.hasNext()) {
            val contactGroup = contactGroups.next() as ContactGroupJabberImpl?
            contact = contactGroup!!.findContact(id)
            if (contact != null) return contact
        }

        // check for private contacts
        val volatileGroup = nonPersistentGroup
        if (volatileGroup != null) {
            contact = volatileGroup.findContact(id)
            if (contact != null) return contact
        }

        // try the root group for non-group contact
        return rootGroup.findContact(id)
    }

    /**
     * Returns the ContactGroup containing the specified contact or null if no such group or contact exist.
     *
     * @param child the contact whose parent group we're looking for.
     * @return the `ContactGroup` containing the specified `contact` or `null`
     * if no such group or contact exist.
     */
    fun findContactGroup(child: ContactJabberImpl): ContactGroup? {
        val contactGroups = rootGroup.subgroups()
        val contactJid = child.contactJid
        while (contactGroups!!.hasNext()) {
            val contactGroup = contactGroups.next() as ContactGroupJabberImpl?
            if (contactGroup!!.findContact(contactJid) != null) return contactGroup
        }

        // try the root group for non-grouped contact
        return if (rootGroup.findContact(contactJid) != null) rootGroup else null
    }

    /**
     * Adds a new contact with the specified screenName to the contactList in rootGroup.
     *
     * @param id the id of the contact to add.
     * @param pps the pps requesting for contact to add.
     * @throws OperationFailedException OperationFailedException, XmppStringprepException
     */
    @Throws(OperationFailedException::class)
    fun addContact(pps: ProtocolProviderService?, id: String?) {
        rootGroupPPS = pps
        addContact(getRootGroup(), id)
    }

    /**
     * Adds a new contact with the specified screenName to the list under the specified group.
     * Also include StanzaListener to intercept <presence type='subscribe'></presence> to add support for
     * XEP-0172: User Nickname extension for this contact.
     *
     * @param id the id of the contact to add.
     * @param parent the group under which we want the new contact placed.
     * @throws OperationFailedException if the contact already exist
     */
    @Throws(OperationFailedException::class)
    fun addContact(parent: ContactGroup?, id: String?) {
        Timber.log(TimberLog.FINER, "Adding contact %s to parent = %s", id, parent)
        val contactJid = parseAddressString(id)

        // if the contact is already in the contact list and is not volatile, then only broadcast an event
        // Should also check new owner against existing old owner, not just bareJid.
        var accountUuid: String? = null
        var mcGroupName: String? = null
        var parentNames: Array<String?>? = null
        if (parent != null) {
            mcGroupName = parent.getGroupName()
            if (parent === getRootGroup()) {
                accountUuid = rootGroupPPS!!.accountID.accountUuid
            } else {
                accountUuid = parent.getProtocolProvider()!!.accountID.accountUuid
                parentNames = arrayOf(mcGroupName)
            }
        }
        val args = arrayOf(accountUuid, mcGroupName, contactJid.toString())
        val mDB = DatabaseBackend.writableDB
        val cursor = mDB.query(MetaContactGroup.TBL_CHILD_CONTACTS, null,
                MetaContactGroup.ACCOUNT_UUID + "=? AND " + MetaContactGroup.PROTO_GROUP_UID
                        + "=? AND " + MetaContactGroup.CONTACT_JID + "=?", args, null, null, null)
        if (cursor.count > 0) {
            cursor.close()
            Timber.w("Contact %s already exists in group %s", contactJid, findContactGroup(contactJid.toString()))
            throw OperationFailedException("Contact $contactJid already exist",
                    OperationFailedException.SUBSCRIPTION_ALREADY_EXISTS)
        }
        cursor.close()

        // @see <a href="https://xmpp.org/extensions/xep-0172.html">XEP-0172: User Nickname</a>
        xmppConnection!!.addPresenceInterceptor({ presenceBuilder: PresenceBuilder ->
            val presence = presenceBuilder.build()
            if (presence.to.isParentOf(contactJid)) {
                val nicknameExt = Nick(JabberActivator.globalDisplayDetailsService!!.getDisplayName(parentProvider))
                presenceBuilder.addExtension(nicknameExt)

                // cmeng - End the listener once job is completed
                // xmppConnection.removePresenceInterceptor(this);
            }
            Timber.w("Presence subscribe for: %s", contactJid)
        }) { packet: Presence? -> PresenceTypeFilter.SUBSCRIBE.accept(packet) }

        /* Creates a new roster entry and presence subscription. The server will asynchronously
         * update the roster with the subscription status.
         */
        try {
            mRoster!!.createItemAndRequestSubscription(contactJid, contactJid.toString(), parentNames)
        } catch (ex: XMPPErrorException) {
            var errTxt: String? = "Error adding new jabber roster entry"
            Timber.e(ex, "%s", errTxt)
            var errorCode = OperationFailedException.INTERNAL_ERROR
            val error = ex.stanzaError
            if (error != null) {
                errorCode = when (error.condition) {
                    StanzaError.Condition.forbidden, StanzaError.Condition.not_allowed, StanzaError.Condition.not_authorized -> OperationFailedException.FORBIDDEN
                    else -> OperationFailedException.INTERNAL_SERVER_ERROR
                }
                errTxt = error.descriptiveText
            }
            throw OperationFailedException(errTxt, errorCode, ex)
        } catch (ex: NotLoggedInException) {
            ex.printStackTrace()
        } catch (ex: NoResponseException) {
            ex.printStackTrace()
        } catch (ex: NotConnectedException) {
            ex.printStackTrace()
        } catch (ex: InterruptedException) {
            ex.printStackTrace()
        }
    }

    /**
     * Creates a non persistent contact for the specified address. This would also create (if
     * necessary) a group for volatile contacts that would not be added to the server stored
     * contact list. This method would have no effect on the server stored contact list.
     *
     * @param id the address of the contact to create.
     * @param isPrivateMessagingContact indicates if the contact should be private messaging contact or not.
     * @param displayName the display name of the contact
     * @return the newly created volatile `ContactImpl`
     */
    fun createVolatileContact(id: Jid, isPrivateMessagingContact: Boolean, displayName: String?): ContactJabberImpl {
        // Timber.w(new Exception(), "Create volatile contact: %s (%s)", id, displayName);
        val newVolatileContact = VolatileContactJabberImpl(id, this, isPrivateMessagingContact, displayName)

        // Check whether a volatile group already exists and if not create one
        var theVolatileGroup = nonPersistentGroup

        // if the parent group is null then add necessary to create the group
        if (theVolatileGroup == null) {
            theVolatileGroup = VolatileContactGroupJabberImpl(ContactGroup.VOLATILE_GROUP, this)
            theVolatileGroup.addContact(newVolatileContact)
            rootGroup.addSubGroup(theVolatileGroup)
            fireGroupEvent(theVolatileGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT)
        } else {
            theVolatileGroup.addContact(newVolatileContact)
            fireContactAdded(theVolatileGroup, newVolatileContact)
        }
        return newVolatileContact
    }

    /**
     * Checks if the contact address is associated with private messaging contact or not.
     *
     * @param contactJid the address of the contact.
     * @return `true` the contact address is associated with private messaging contact and `false` if not.
     */
    fun isPrivateMessagingContact(contactJid: Jid?): Boolean {
        val theVolatileGroup = nonPersistentGroup ?: return false
        val contact = theVolatileGroup.findContact(contactJid)
        return if (contact !is VolatileContactJabberImpl) false else contact.isPrivateMessagingContact
    }

    /**
     * Creates a non resolved contact for the specified address and inside the specified group. The
     * newly created contact would be added to the local contact list as a standard contact but
     * when an event is received from the server concerning this contact, then it will be reused
     * and only its isResolved field would be updated instead of creating the whole contact again.
     *
     * @param parentGroup the group where the unresolved contact is to be created
     * @param id the Address of the contact to create.
     * @return the newly created unresolved `ContactImpl`
     */
    @Synchronized
    fun createUnresolvedContact(parentGroup: ContactGroup?, id: Jid?): ContactJabberImpl {
        val existingContact = findContactById(id)
        if (existingContact != null) {
            return existingContact
        }
        val newUnresolvedContact = ContactJabberImpl(id!!, this, true)
        if (parentGroup is ContactGroupJabberImpl) parentGroup.addContact(newUnresolvedContact) else if (parentGroup is RootContactGroupJabberImpl) parentGroup.addContact(newUnresolvedContact)
        fireContactAdded(parentGroup, newUnresolvedContact)
        return newUnresolvedContact
    }

    /**
     * Creates a non resolved contact group for the specified name. The newly created group would
     * be added to the local contact list as any other group but when an event is received from the
     * server concerning this group, then it will be reused and only its isResolved field would be
     * updated instead of creating the whole group again.
     *
     * @param groupName the name of the group to create.
     * @return the newly created unresolved `ContactGroupImpl`
     */
    @Synchronized
    fun createUnresolvedContactGroup(groupName: String): ContactGroupJabberImpl {
        val existingGroup = findContactGroup(groupName)
        if (existingGroup != null) {
            return existingGroup
        }
        val newUnresolvedGroup = ContactGroupJabberImpl(groupName, this)
        rootGroup.addSubGroup(newUnresolvedGroup)
        fireGroupEvent(newUnresolvedGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT)
        return newUnresolvedGroup
    }

    /**
     * Creates the specified group on the server stored contact list.
     *
     * @param groupName a String containing the name of the new group.
     * @throws OperationFailedException with code CONTACT_GROUP_ALREADY_EXISTS if the group we're trying
     * to create is already in our contact list.
     */
    @Throws(OperationFailedException::class)
    fun createGroup(groupName: String) {
        Timber.d("Creating group: %s", groupName)
        val existingGroup = findContactGroup(groupName)
        if (existingGroup != null && existingGroup.isPersistent()) {
            Timber.d("ContactGroup %s already exists.", groupName)
            throw OperationFailedException("ContactGroup $groupName already exists.",
                    OperationFailedException.CONTACT_GROUP_ALREADY_EXISTS)
        }
        val newRosterGroup = mRoster!!.createGroup(groupName)
        val newGroup = ContactGroupJabberImpl(newRosterGroup,
                Collections.emptyIterator(), this, true)
        rootGroup.addSubGroup(newGroup)
        fireGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT)
        Timber.log(TimberLog.FINER, "Group %s created.", groupName)
    }

    /**
     * Removes the specified group from the buddy list.
     *
     * @param groupToRemove the group that we'd like removed.
     */
    @Throws(OperationFailedException::class)
    fun removeGroup(groupToRemove: ContactGroupJabberImpl) {
        try {
            // first copy the item that will be removed when iterating over group contacts and
            // removing them concurrent exception occurs
            val localCopy = Vector<Contact?>()
            var iter = groupToRemove.contacts()
            while (iter!!.hasNext()) {
                localCopy.add(iter.next())
            }
            iter = localCopy.iterator()
            while (iter.hasNext()) {
                val item = iter.next() as ContactJabberImpl?
                if (item!!.isPersistent) mRoster!!.removeEntry(item.getSourceEntry())
            }
        } catch (ex: XMPPException) {
            Timber.e(ex, "Error removing group")
            throw OperationFailedException(ex.message, OperationFailedException.GENERAL_ERROR, ex)
        } catch (e: NotLoggedInException) {
            e.printStackTrace()
        } catch (e: NoResponseException) {
            e.printStackTrace()
        } catch (e: NotConnectedException) {
            e.printStackTrace()
        } catch (e: InterruptedException) {
            e.printStackTrace()
        }
    }

    /**
     * Removes a contact from the server side list Event will come for successful operation
     *
     * @param contactToRemove ContactJabberImpl
     */
    @Throws(OperationFailedException::class)
    fun removeContact(contactToRemove: ContactJabberImpl) {
        // Allow direct removal of any VolatileContactJabberImpl if it is not DomainBareJid
        if (contactToRemove.contactJid is DomainBareJid) return

        // aTalk implementation is ContactGroup.VOLATILE_GROUP is equivalent to "VolatileContactJabberImpl"
        when {
            contactToRemove is VolatileContactJabberImpl || ((contactToRemove.parentContactGroup != null) && (ContactGroup.VOLATILE_GROUP == contactToRemove.parentContactGroup!!.getGroupName())) -> {
                contactDeleted(contactToRemove)
                return
            }

            //don't try to remove non-existing contacts.
            else -> {
                val entry = contactToRemove.getSourceEntry()
                if (entry != null) {
                    try {
                        mRoster!!.removeEntry(entry)
                    } catch (ex: XMPPErrorException) {
                        var errTxt: String? = "Error removing contact"
                        var errorCode = OperationFailedException.INTERNAL_ERROR
                        val error = ex.stanzaError
                        if (error != null) {
                            errTxt = error.descriptiveText
                            if (error.condition == StanzaError.Condition.internal_server_error) errorCode = OperationFailedException.INTERNAL_SERVER_ERROR else if (error.condition == StanzaError.Condition.forbidden) errorCode = OperationFailedException.FORBIDDEN else if (error.condition == StanzaError.Condition.bad_request) errorCode = OperationFailedException.ILLEGAL_ARGUMENT
                        }
                        Timber.e(ex, "%s", errTxt)
                        throw OperationFailedException(errTxt, errorCode, ex)
                    } catch (ex: NotLoggedInException) {
                        ex.printStackTrace()
                    } catch (ex: NoResponseException) {
                        ex.printStackTrace()
                    } catch (ex: NotConnectedException) {
                        ex.printStackTrace()
                    } catch (ex: InterruptedException) {
                        ex.printStackTrace()
                    }
                }
            }
        }
    }

    /**
     * Renames the specified group according to the specified new name.
     *
     * @param groupToRename the group that we'd like removed.
     * @param newName the new name of the group
     */
    fun renameGroup(groupToRename: ContactGroupJabberImpl, newName: String?) {
        try {
            groupToRename.getSourceGroup().name = newName
            groupToRename.setNameCopy(newName)
        } catch (e: NotConnectedException) {
            Timber.e("Could not rename %s to %s", groupToRename, newName)
        } catch (e: NoResponseException) {
            Timber.e("Could not rename %s to %s", groupToRename, newName)
        } catch (e: XMPPErrorException) {
            Timber.e("Could not rename %s to %s", groupToRename, newName)
        } catch (e: InterruptedException) {
            Timber.e("Could not rename %s to %s", groupToRename, newName)
        }
        groupToRename.setNameCopy(newName)
    }

    /**
     * Moves the specified `contact` to the group indicated by `newParent`.
     *
     * @param contact the contact that we'd like moved under the new group.
     * @param newParent the group where we'd like the parent placed.
     */
    @Throws(OperationFailedException::class)
    fun moveContact(contact: ContactJabberImpl, newParent: AbstractContactGroupJabberImpl) {
        // when the contact is not persistent, coming from NotInContactList group, we need just
        // to add it to the list
        if (!contact.isPersistent) {
            val contactAddress: String? = if (contact is VolatileContactJabberImpl
                    && contact.isPrivateMessagingContact) {
                contact.getPersistableAddress()
            } else {
                contact.address
            }
            try {
                addContact(newParent, contactAddress)
                return
            } catch (ex: OperationFailedException) {
                Timber.e(ex, "Cannot move contact!")
                throw OperationFailedException(ex.message, OperationFailedException.GENERAL_ERROR, ex)
            }
        }

        // create the entry with the new group so it can be removed from other groups if any.
        // modify our reply timeout because some XMPP may send "result" IQ late (> 5 seconds).
        xmppConnection!!.replyTimeout = ProtocolProviderServiceJabberImpl.SMACK_REPLY_EXTENDED_TIMEOUT_30
        try {
            mRoster!!.createItemAndRequestSubscription(contact.getSourceEntry()!!.jid, contact.displayName, arrayOf(newParent.getGroupName()))
            newParent.addContact(contact)
        } catch (ex: XMPPException) {
            Timber.e(ex, "Cannot move contact!")
            throw OperationFailedException(ex.message, OperationFailedException.GENERAL_ERROR, ex)
        } catch (e: NotLoggedInException) {
            e.printStackTrace()
        } catch (e: NoResponseException) {
            e.printStackTrace()
        } catch (e: NotConnectedException) {
            e.printStackTrace()
        } catch (e: InterruptedException) {
            e.printStackTrace()
        } finally {
            // Reset to default
            xmppConnection!!.replyTimeout = ProtocolProviderServiceJabberImpl.SMACK_REPLY_TIMEOUT_DEFAULT
        }
    }

    /**
     * Sets a reference to the currently active and valid instance of roster that this list is to
     * be used for retrieving server stored information
     */
    fun init(presenceChangeListener: ContactChangesListener) {
        // FFR: v2.1.6 Huawei nova 3i/Y9 prime (HWINE) android-9, xmppConnection == null
        // This may be called when PPS is not-registered ???? called at RegistrationState.REGISTERED state
        xmppConnection = parentProvider.connection
        mRoster = Roster.getInstanceFor(xmppConnection)
        initRoster()
        val avatarManager = AvatarManager.getInstanceFor(xmppConnection)
        try {
            avatarManager.saveAccountRoster(xmppConnection!!.user.asBareJid())
        } catch (e: XmppStringprepException) {
            e.printStackTrace()
        }

        // roster has been requested or loaded and dispatched, mark this
        synchronized(rosterInitLock) { isRosterInitialized = true }

        // now send initial presence status that was on hold earlier
        sendInitialStatus()
        // FFR: v3.0.5 Huawei HWELE android-10, presenceChangeListener == null ???
        // presenceChangeListener was init in registering and this method is called at registered????
        presenceChangeListener.processStoredEvents()
        rosterChangeListener = ChangeListener()
        // v2.2.2. mRoster => NPE
        mRoster!!.addRosterListener(rosterChangeListener)
    }

    /**
     * Sends the initial presence to server. RFC 6121 says: a client SHOULD request the roster
     * before sending initial presence We extend this and send it after we have dispatched the roster.
     *
     * Note: Ensure only <x xmlns='vcard-temp:x:update'></x> extension without the <photo></photo> element is
     * added if avatar photo has yet to be downloaded from server. Refer to XEP-0153: vCard-Based
     * Avatars section Example 6. User Is Not Ready to Advertise an Image
     */
    private fun sendInitialStatus() {
        // if we have initial status saved then send it after roster has completed
        if (initialStatus != null) {
            try {
                parentOperationSet!!.publishPresenceStatus(initialStatus, initialStatusMessage)
            } catch (ex: Exception) {
                Timber.e(ex, "Error publishing initial presence")
            }
        } else if (parentProvider.getOperationSet(OperationSetPersistentPresence::class.java) == null) {
            Timber.w("Smack sending presence without OpSetPP support!")
            try {
                val connection = parentProvider.connection
                val presenceBuilder = connection!!.stanzaFactory.buildPresenceStanza()
                        .ofType(Presence.Type.available)
                connection.sendStanza(presenceBuilder.build())
            } catch (e: NotConnectedException) {
                e.printStackTrace()
            } catch (e: InterruptedException) {
                e.printStackTrace()
            }
        }
        // clean
        initialStatus = null
        initialStatusMessage = null
    }

    /**
     * Cleanups references and listeners.
     */
    fun cleanup() {
        if (imageRetriever != null) {
            imageRetriever!!.quit()
            imageRetriever = null
        }
        if (mRoster != null) mRoster!!.removeRosterListener(rosterChangeListener)
        rosterChangeListener = null
        mRoster = null
        synchronized(rosterInitLock) { isRosterInitialized = false }
    }

    /**
     * When the protocol is online this method is used to Synchronous the current metaContactList
     * with the received roster
     */
    @Synchronized
    private fun initRoster() {
        // first if non-filed entries will move them in a group
        if (mRoster!!.unfiledEntryCount > 0) {
            for (item in mRoster!!.unfiledEntries) {
                var contact = findContactById(item.jid)

                // some services automatically add contacts from their address book to the roster,
                // and those contacts are with subscription none. If such already exist, remove them.
                // This is typically our own contact
                if (!isEntryDisplayable(item)) {
                    if (contact != null) {
                        val parent = contact.parentContactGroup
                        if (parent is RootContactGroupJabberImpl) parent.removeContact(contact) else (parent as ContactGroupJabberImpl?)!!.removeContact(contact)
                        fireContactRemoved(parent, contact)
                    }
                    continue
                }

                // if there is no such contact create it
                if (contact == null) {
                    contact = ContactJabberImpl(item, this, isPersistent = true, isResolved = true)
                    rootGroup.addContact(contact)
                    fireContactAdded(rootGroup, contact)
                } else {
                    val group = contact.parentContactGroup
                    // cmeng - Cannot just compare groups of different instanceOf.
                    // Do not move contact or if request is of the same group.
                    if (rootGroup.getGroupName() != group!!.getGroupName()) {
                        contactMoved(group, rootGroup, contact)
                    }
                    // if contact exist so resolve it
                    contact.setResolved(item)

                    // fire an event saying that the non-filed contact has been resolved
                    fireContactResolved(rootGroup, contact)
                }

                /*
                 * process status if any that was received while the roster reply packet was received and added
                 * our presence listener. Fixes a problem where Presence packets can be received before the roster
                 * items packet, and we miss it, cause we add our listener after roster is received and smack
                 * don't allow to add our listener earlier
                 */
                // cmeng - already done in either fireContactAdded() or fireContactResolved() method
                // Duplicated entry in storedPresences if allow to be executed.
                // parentOperationSet.firePresenceStatusChanged(mRoster.getPresence(item.getJid()));
            }
        }

        // now search all root contacts for unresolved ones
        val contacts = rootGroup.contacts()
        val contactsToRemove: MutableList<ContactJabberImpl?> = ArrayList()
        while (contacts!!.hasNext()) {
            val contact = contacts.next() as ContactJabberImpl?
            if (!contact!!.isResolved()) {
                contactsToRemove.add(contact)
            }
        }
        for (contact in contactsToRemove) {
            rootGroup.removeContact(contact)
            fireContactRemoved(rootGroup, contact)
        }
        contactsToRemove.clear()
        for (item in mRoster!!.groups) {
            val group = findContactGroup(item.name)
            if (group != null) {
                // the group exist so just resolved. The group will check and create or resolve its entries
                group.setResolved(item)

                // fire an event saying that the group has been resolved
                fireGroupEvent(group, ServerStoredGroupEvent.GROUP_RESOLVED_EVENT)
            }
        }
        val iterGroups = rootGroup.subgroups()
        val groupsToRemove: MutableList<ContactGroupJabberImpl?> = ArrayList()
        while (iterGroups!!.hasNext()) {
            // group can be RootContactGroupJabberImpl or ContactGroupJabberImpl
            val group = iterGroups.next() as ContactGroupJabberImpl?

            // cmeng: all current aTalk groups are set to be persistent including volatileGroup (domainJid);
            // Need to skip further checking to avoid removal on isResolved == false
            // so invalid to skip non persistent groups if (!group.isPersistent())
            if (ContactGroup.VOLATILE_GROUP == group!!.getGroupName()) continue

            // cmeng - Must not remove root group in new SQLite database implementation.
            // Need special check here as all ContactGroups have been casted to
            // ContactGroupJabberImpl including RootContactGroupJabberImpl
            if (ContactGroup.ROOT_PROTO_GROUP_UID != group.getGroupName() && !group.isResolved()) {
                groupsToRemove.add(group)
            }
            val iterContacts = group.contacts()
            while (iterContacts!!.hasNext()) {
                val contact = iterContacts.next() as ContactJabberImpl?
                if (!contact!!.isResolved()) {
                    contactsToRemove.add(contact)
                }
            }
            for (contact in contactsToRemove) {
                group.removeContact(contact!!)
                fireContactRemoved(group, contact)
            }
            contactsToRemove.clear()
        }
        for (group in groupsToRemove) {
            rootGroup.removeSubGroup(group)
            fireGroupEvent(group, ServerStoredGroupEvent.GROUP_REMOVED_EVENT)
        }

        // fill in root group
        for (item in mRoster!!.groups) {
            val group = findContactGroup(item.name)

            // create the group as it doesn't exist
            if (group == null) {
                val newGroup = ContactGroupJabberImpl(item, item.entries.iterator(), this, true)
                rootGroup.addSubGroup(newGroup)

                // tell listeners about the added group
                fireGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT)

                // if presence was already received it, we must check & dispatch it
                if (mRoster != null) {
                    val cIter = newGroup.contacts()
                    while (cIter!!.hasNext()) {
                        val contactJid = cIter.next()!!.contactJid
                        parentOperationSet!!.firePresenceStatusChanged(mRoster!!.getPresence(contactJid!!.asBareJid()))
                    }
                }
            }
        }
    }

    /**
     * Returns the volatile group that we use when creating volatile contacts.
     * VolatileGroup is now set to persistent to save to DB
     *
     * @return ContactGroupJabberImpl
     */
    val nonPersistentGroup: ContactGroupJabberImpl?
        get() {
            for (i in 0 until getRootGroup().countSubgroups()) {
                val gr = getRootGroup().getGroup(i) as ContactGroupJabberImpl?
                if (ContactGroup.VOLATILE_GROUP == gr!!.getGroupName()) return gr
            }
            return null
        }

    /**
     * Make the parent persistent presence operation set dispatch a contact added event.
     *
     * @param parentGroup the group where the new contact was added
     * @param contact the contact that was added
     */
    fun fireContactAdded(parentGroup: ContactGroup?, contact: ContactJabberImpl) {
        // bail out if no one's listening
        if (parentOperationSet == null) {
            Timber.d("No presence op. set available. Bailing out.")
            return
        }

        // if we are already registered (roster != null), and we are currently creating the contact list,
        // presences maybe already received before we have created the contacts, so let's check
        if (mRoster != null) {
            parentOperationSet.firePresenceStatusChanged(mRoster!!.getPresence(contact.contactJid!!.asBareJid()))
        }

        // dispatch
        parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_CREATED)
    }

    /**
     * Make the parent persistent presence operation set dispatch a contact resolved event.
     *
     * @param parentGroup the group the resolved contact belongs to.
     * @param contact the contact that was resolved
     */
    fun fireContactResolved(parentGroup: ContactGroup?, contact: ContactJabberImpl) {
        // bail out if no one's listening
        if (parentOperationSet == null) {
            Timber.d("No presence op. set available. Bailing out.")
            return
        }

        // if we are already registered(roster != null) and we are currently creating the contact
        // list, presences maybe already received before we have created the contacts, so lets check
        if (mRoster != null) {
            parentOperationSet.firePresenceStatusChanged(mRoster!!.getPresence(contact.contactJid!!.asBareJid()))
        }

        // dispatch
        parentOperationSet.fireSubscriptionEvent(contact, parentGroup, SubscriptionEvent.SUBSCRIPTION_RESOLVED)
    }

    /**
     * When there is no photo image for a contact, we need to retrieve it by adding the contact
     * into contactsForUpdate arrayList for image update
     *
     * @param contact ContactJabberImpl
     * @see ImageRetriever.contactsForUpdate
     */
    fun addContactForImageUpdate(contact: ContactJabberImpl) {
        if (contact is VolatileContactJabberImpl
                && contact.isPrivateMessagingContact) return
        if (imageRetriever == null) {
            imageRetriever = ImageRetriever()
            imageRetriever!!.start()
        }
        imageRetriever!!.addContact(contact)
    }

    /**
     * @param enable if set enable the retrieval of avatar from server if null
     */
    fun setRetrieveOnStart(enable: Boolean) {
        infoRetrieveOnStart = enable
    }

    /**
     * Removes contact from client side.
     *
     * @param contact the contact to be deleted.
     */
    private fun contactDeleted(contact: ContactJabberImpl) {
        val group = findContactGroup(contact)
        if (group == null) {
            Timber.log(TimberLog.FINER, "Could not find ParentGroup for deleted entry:%s", contact.address)
            return
        }
        if (group is ContactGroupJabberImpl) {

            // remove the contact from parent group
            group.removeContact(contact)

            // Remove groupImpl from rootGroup if it is empty list and it is not the rootGroup.
            // This deleted group will also be removed from server if empty
            if (group.countContacts() == 0 && group != getRootGroup()) {
                rootGroup.removeSubGroup(group)
                fireContactRemoved(group, contact)
                fireGroupEvent(group, ServerStoredGroupEvent.GROUP_REMOVED_EVENT)
            } else fireContactRemoved(group, contact)
        } else if (group is RootContactGroupJabberImpl) {
            rootGroup.removeContact(contact)
            fireContactRemoved(rootGroup, contact)
        }
    }

    /**
     * Receive changes in the roster.
     */
    private inner class ChangeListener : RosterListener {
        /**
         * Received an event when entry is added to the server stored list
         *
         * @param addresses Collection of contact Jid
         */
        override fun entriesAdded(addresses: Collection<Jid>) {
            Timber.log(TimberLog.FINER, "entries Added %s", addresses)
            for (id in addresses) {
                addEntryToContactList(id)
            }
        }

        /**
         * Adds the entry to our local contactList. If contact exists and is persistent but not
         * resolved, we resolve it and return it without adding new contact. If the contact exists
         * and is not persistent, we remove it, to avoid duplicate contacts and add the new one.
         * All entries must be displayable before we done anything with them.
         *
         * @param rosterEntryID the entry id.
         * @return the newly created contact.
         */
        private fun addEntryToContactList(rosterEntryID: Jid): ContactJabberImpl? {
            val entry = mRoster!!.getEntry(rosterEntryID.asBareJid())
            if (!isEntryDisplayable(entry)) return null
            var contact = findContactById(entry.jid)
            if (contact == null) {
                contact = findPrivateContactByRealId(entry.jid)
            }
            if (contact != null) {
                if (contact.isPersistent) {
                    contact.setResolved(entry)
                    return contact
                } else if (contact is VolatileContactJabberImpl) {
                    val oldParentGroup = contact.parentContactGroup
                    // If contact is in 'notInContactList' we must remove it from there in order
                    // to correctly process adding contact this happens if we accept subscribe
                    // request not from sip-communicator
                    if (oldParentGroup is ContactGroupJabberImpl && !oldParentGroup.isPersistent()) {
                        oldParentGroup.removeContact(contact)
                        fireContactRemoved(oldParentGroup, contact)
                    }
                } else return contact
            }

            // Not in local group, then create and add new local contact
            contact = ContactJabberImpl(entry, this@ServerStoredContactListJabberImpl, isPersistent = true, isResolved = true)
            if (entry.groups.size == 0) {
                // no parent group so its in the root group
                rootGroup.addContact(contact)
                fireContactAdded(rootGroup, contact)
                return contact
            }
            for (group in entry.groups) {
                val parentGroup = findContactGroup(group.name)
                if (parentGroup != null) {
                    parentGroup.addContact(contact)
                    fireContactAdded(findContactGroup(contact), contact)
                } else {
                    // create the group as it doesn't exist
                    val newGroup = ContactGroupJabberImpl(group, group.entries.iterator(),
                            this@ServerStoredContactListJabberImpl, true)
                    rootGroup.addSubGroup(newGroup)

                    // tell listeners about the added group
                    fireGroupEvent(newGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT)
                }
                // as for now we only support contact in one group
                return contact
            }
            return contact
        }

        /**
         * Finds private messaging contact by its jabber id.
         *
         * @param id the jabber id.
         * @return the contact or null if the contact is not found.
         */
        private fun findPrivateContactByRealId(id: Jid): ContactJabberImpl? {
            val volatileGroup: ContactGroupJabberImpl = nonPersistentGroup ?: return null
            val it = volatileGroup.contacts()
            while (it!!.hasNext()) {
                val contact = it.next()
                if (contact!!.getPersistableAddress() == null) continue
                if (contact.getPersistableAddress() == id.asBareJid().toString()) {
                    return contact as ContactJabberImpl?
                }
            }
            return null
        }

        /**
         * Event when an entry is updated. Something new for the entry data
         * or have been added to a new group or removed from one
         *
         * @param addresses Collection of Contact Jid's
         */
        override fun entriesUpdated(addresses: Collection<Jid>) {
            Timber.log(TimberLog.FINER, "entries Updated %s", addresses)

            // will search for group renamed
            for (contactJid in addresses) {
                val entry = mRoster!!.getEntry(contactJid.asBareJid())
                val contact = addEntryToContactList(contactJid) ?: continue
                if (entry.groups.isEmpty()) {
                    // check for change in display name
                    checkForRename(entry.name, contact)
                    val contactGroup = contact.parentContactGroup
                    if (rootGroup != contactGroup) {
                        contactMoved(contactGroup, rootGroup, contact)
                    }
                }
                for (gr in entry.groups) {
                    var cgr: ContactGroup? = findContactGroup(gr.name)

                    // Check for ROOT_GROUP_NAME if null
                    if (cgr == null) {
                        // ROOT_GROUP_NAME (contacts) is not listed in subGroups() for search. Need special handle
                        if (ContactGroup.ROOT_GROUP_NAME == gr.name) {
                            cgr = getRootGroup()
                        } else {
                            val group = findContactGroupByNameCopy(gr.name)
                            if (group != null) {
                                // just change the source entry
                                group.setSourceGroup(gr)
                                fireGroupEvent(group, ServerStoredGroupEvent.GROUP_RENAMED_EVENT)
                            } else {
                                // the group was renamed in a different location, so we do not have it at
                                // our side now; let's find the group for the contact and rename it;
                                // if it is the only contact in the group then rename, otherwise move
                                val currentParentGroup = contact.parentContactGroup
                                if (currentParentGroup!!.countContacts() > 1) {
                                    cgr = currentParentGroup
                                } else {
                                    // make sure this group name is not present in entry groups
                                    var present = false
                                    for (entryGr in entry.groups) {
                                        if (entryGr.name == currentParentGroup.getGroupName()) {
                                            present = true
                                            break
                                        }
                                    }
                                    if (!present && currentParentGroup is ContactGroupJabberImpl) {
                                        currentParentGroup.setSourceGroup(gr)
                                        fireGroupEvent(currentParentGroup, ServerStoredGroupEvent.GROUP_RENAMED_EVENT)
                                    }
                                }
                            }
                        }
                    }

                    // the group is found the contact may be moved from one group to another
                    if (cgr != null) {
                        val contactGroup = contact.parentContactGroup

                        // contact parent group is different, then add it to the new one
                        if (gr.name != contactGroup!!.getGroupName()) {
                            var newParentGroup: ContactGroup? = findContactGroup(gr.name)

                            // Proceed to add the new parent group if none found
                            if (newParentGroup == null) {
                                // ROOT_GROUP_NAME (contacts) is not listed in subGroups() for search. Need special handle
                                if (ContactGroup.ROOT_GROUP_NAME == gr.name) {
                                    newParentGroup = getRootGroup()
                                } else {
                                    // create the group as it doesn't exist
                                    newParentGroup = ContactGroupJabberImpl(gr, Collections.emptyIterator(),
                                            this@ServerStoredContactListJabberImpl, true)
                                    rootGroup.addSubGroup(newParentGroup)
                                    // tell listeners about the added group
                                    fireGroupEvent(newParentGroup, ServerStoredGroupEvent.GROUP_CREATED_EVENT)
                                }
                            }
                            contactMoved(contactGroup, newParentGroup, contact)
                        } else {
                            // check for change in display name
                            checkForRename(entry.name, contact)
                        }
                    }
                }
            }
        }

        /**
         * Checks the entry and the contact whether the display name has changed.
         *
         * @param newValue new display name value
         * @param contact the contact to check
         */
        private fun checkForRename(newValue: String?, contact: ContactJabberImpl) {
            // check for change in display name
            if (newValue != null && newValue != contact.serverDisplayName) {
                val oldValue = contact.serverDisplayName
                contact.serverDisplayName = newValue
                parentOperationSet!!.fireContactPropertyChangeEvent(contact,
                        ContactPropertyChangeEvent.PROPERTY_DISPLAY_NAME, oldValue, newValue)
            }
        }

        /**
         * Event received when entry has been removed from the list
         *
         * @param addresses Collection
         */
        override fun entriesDeleted(addresses: Collection<Jid>) {
            for (contactJid in addresses) {
                Timber.log(TimberLog.FINER, "entry deleted %s", contactJid)
                val contact = findContactById(contactJid)
                if (contact == null) {
                    Timber.d("Could not find contact for deleted entry: %s", contactJid)
                    continue
                }
                contactDeleted(contact)
            }
        }

        /**
         * Not used here.
         *
         * @param presence the presence that changed.
         */
        override fun presenceChanged(presence: Presence) {}
    }

    /**
     * Thread for retrieving contacts' images.
     */
    private inner class ImageRetriever : Thread() {
        /**
         * list with the accounts with missing image
         */
        private val contactsForUpdate: MutableList<ContactJabberImpl> = Vector()

        /**
         * Should we stop.
         */
        private var running = false

        /**
         * Creates image retrieving.
         */
        init {
            isDaemon = true
        }

        /**
         * Thread entry point.
         */
        override fun run() {
            try {
                var copyContactsForUpdate: Collection<ContactJabberImpl>
                running = true
                while (running) {
                    synchronized(contactsForUpdate) {
                        if (contactsForUpdate.isEmpty()) contactsForUpdate.wait()
                        if (!running) return
                        copyContactsForUpdate = Vector(contactsForUpdate)
                        contactsForUpdate.clear()
                    }
                    for (contact in copyContactsForUpdate) {
                        val imgBytes = getAvatar(contact)
                        val oldImage = contact.getImage(false)
                        contact.image =imgBytes
                        parentOperationSet!!.fireContactPropertyChangeEvent(contact,
                                ContactPropertyChangeEvent.PROPERTY_IMAGE, oldImage, imgBytes)
                    }
                }
            } catch (ex: InterruptedException) {
                Timber.e(ex, "ImageRetriever error waiting will stop now!")
            }
        }

        /**
         * Add contact for retrieving:
         * - if the provider is registered notify the retriever to get the nicks
         * - if we are not registered add a listener to wait for registering
         *
         * @param contact ContactJabberImpl
         */
        fun addContact(contact: ContactJabberImpl) {
            synchronized(contactsForUpdate) {
                if (!contactsForUpdate.contains(contact)) {
                    contactsForUpdate.add(contact)
                    contactsForUpdate.notifyAll()
                }
            }
        }

        /**
         * Stops this thread.
         */
        fun quit() {
            synchronized(contactsForUpdate) {
                running = false
                contactsForUpdate.notifyAll()
            }
        }

        /**
         * Retrieves the avatar. Use image from persistent storage if found. Otherwise proceed to
         * load avatar from VCard.
         *
         * @param contact the contact.
         * @return the contact avatar.
         */
        private fun getAvatar(contact: ContactJabberImpl): ByteArray {
            val userJid = contact.contactJid!!.asBareJid()
            val userId = userJid.toString()
            var result = VCardAvatarManager.getAvatarImageByJid(userJid)
            if (result == null && infoRetrieveOnStart) {
                Timber.i("Proceed to getAvatar for: %s", userId)
                try {
                    val iter = infoRetriever.getDetails(userJid, ImageDetail::class.java)
                    if (iter.hasNext()) {
                        val imgDetail = iter.next() as ImageDetail?
                        result = imgDetail!!.getBytes()
                    }
                } catch (ex: Exception) {
                    Timber.d(ex, "Cannot load image for contact %s: %s", contact, ex.message)
                }
                if (result == null) {
                    result = searchForCustomAvatar(userId)
                }
            }

            if (result == null) // return no photo if null
                result = ByteArray(0)
            return result
        }
    }

    /**
     * Query custom avatar services and returns the first found avatar.
     *
     * @return the found avatar if any.
     */
    private fun searchForCustomAvatar(address: String): ByteArray? {
        try {
            val refs = JabberActivator.bundleContext.getServiceReferences(CustomAvatarService::class.java.name, null)
                    ?: return null
            for (ref in refs) {
                val avatarService = JabberActivator.bundleContext.getService<Any>(ref as ServiceReference<Any>) as CustomAvatarService
                val res = avatarService.getAvatar(address)
                if (res != null) return res
            }
        } catch (t: Throwable) {
            // if something is wrong just return empty image
        }
        return null
    }

    /**
     * Handles moving of contact from one group to another.
     *
     * @param oldGroup old group of the contact.
     * @param newGroup new group of the contact.
     * @param contact contact to move
     */
    private fun contactMoved(oldGroup: ContactGroup?, newGroup: ContactGroup?,
            contact: ContactJabberImpl) {
        // The contact is moved to another group first, before removing it from the original one
        if (oldGroup is ContactGroupJabberImpl) oldGroup.removeContact(contact) else if (oldGroup is RootContactGroupJabberImpl) oldGroup.removeContact(contact)
        if (newGroup is ContactGroupJabberImpl) newGroup.addContact(contact) else if (newGroup is RootContactGroupJabberImpl) newGroup.addContact(contact)
        fireContactMoved(oldGroup, newGroup, contact)
        if (oldGroup is ContactGroupJabberImpl && oldGroup.countContacts() == 0) {
            // in xmpp if group is empty it is removed
            rootGroup.removeSubGroup(oldGroup as ContactGroupJabberImpl?)
            fireGroupEvent(oldGroup as ContactGroupJabberImpl?, ServerStoredGroupEvent.GROUP_REMOVED_EVENT)
        }
    }

    /**
     * Completes the identifier with the server part if no server part was previously added.
     *
     * @param id the initial identifier as added by the user
     */
    @Throws(OperationFailedException::class)
    private fun parseAddressString(id: String?): EntityBareJid {
        return try {
            val temp = JidCreate.from(id)
            if (!temp.hasLocalpart()) {
                val accountID = parentProvider.accountID
                val accountJid = JidCreate.from(accountID.mUserID)
                return JidCreate.entityBareFrom(Localpart.from(id), accountJid.domain)
            }
            temp.asEntityBareJidOrThrow()
        } catch (e: XmppStringprepException) {
            throw OperationFailedException("Could not parse: $id", 0, e)
        } catch (e: IllegalArgumentException) {
            throw OperationFailedException("Could not parse: $id", 0, e)
        }
    }

    /**
     * Return all the presences for the user or an EMPTY_LIST.
     *
     * @param userJid the bareJid of the user to check for presences.
     * @return all the presences available for the user or an EMPTY_LIST.
     */
    fun getPresences(userJid: BareJid?): List<Presence> {
        return if (mRoster == null || userJid == null) Collections.EMPTY_LIST as List<Presence> else mRoster!!.getPresences(userJid)
    }

    /**
     * Saves the initial status for later dispatching.
     *
     * @param initialStatus to be dispatched later.
     */
    fun setInitialStatus(initialStatus: PresenceStatus?) {
        this.initialStatus = initialStatus
    }

    /**
     * Saves the initial status message for later dispatching.
     *
     * @param initialStatusMessage to be dispatched later.
     */
    fun setInitialStatusMessage(initialStatusMessage: String?) {
        this.initialStatusMessage = initialStatusMessage
    }

    companion object {
        /**
         * Some roster entries are not supposed to be seen. Like some services automatically add
         * contacts from their address book to the roster and those contacts are with subscription none.
         * Best practices in XEP-0162.
         * - subscription='both' or subscription='to'
         * - ((subscription='none' or subscription='from') and ask='subscribe')
         * - ((subscription='none' or subscription='from') and (name attribute or group child))
         *
         * @param entry the entry to check.
         * @return is item to be hidden/ignored.
         */
        fun isEntryDisplayable(entry: RosterEntry): Boolean {
            if (entry.type == ItemType.both || entry.type == ItemType.to) {
                return true
            } else if ((entry.type == ItemType.none || entry.type == ItemType.from)
                    && (entry.isSubscriptionPending || entry.groups.size > 0)) {
                return true
            }
            return false
        }
    }
}