/* * Jitsi, the OpenSource Java VoIP and Instant Messaging client. * * Distributable under LGPL license. See terms of license at gnu.org. */package net.java.sip.communicator.impl.protocol.jabberimport net.java.sip.communicator.service.protocol.*import net.java.sip.communicator.service.protocol.event.CallPeerChangeEventimport net.java.sip.communicator.service.protocol.media.MediaAwareCallPeerimport okhttp3.internal.notifyAllimport org.atalk.hmos.Rimport org.atalk.hmos.aTalkAppimport org.atalk.hmos.gui.call.JingleMessageSessionImplimport org.atalk.service.neomedia.MediaDirectionimport org.atalk.util.MediaTypeimport org.jivesoftware.smack.SmackException.NoResponseExceptionimport org.jivesoftware.smack.SmackException.NotConnectedExceptionimport org.jivesoftware.smack.XMPPExceptionimport org.jivesoftware.smack.XMPPException.XMPPErrorExceptionimport org.jivesoftware.smack.packet.ExtensionElementimport org.jivesoftware.smack.packet.IQimport org.jivesoftware.smack.packet.Stanzaimport org.jivesoftware.smack.roster.Rosterimport org.jivesoftware.smackx.coin.CoinExtensionimport org.jivesoftware.smackx.colibri.ColibriConferenceIQimport org.jivesoftware.smackx.disco.packet.DiscoverInfoimport org.jivesoftware.smackx.jingle.JingleManagerimport org.jivesoftware.smackx.jingle.JingleUtilimport org.jivesoftware.smackx.jingle.element.Jingleimport org.jivesoftware.smackx.jingle.element.JingleContentimport org.jivesoftware.smackx.jingle.element.JingleContent.Sendersimport org.jivesoftware.smackx.jingle.element.JingleReasonimport org.jivesoftware.smackx.jingle_rtp.JingleCallSessionImplimport org.jivesoftware.smackx.jingle_rtp.JingleUtilsimport org.jivesoftware.smackx.jingle_rtp.element.*import org.jivesoftware.smackx.jitsimeet.SSRCInfoExtensionimport org.jxmpp.jid.FullJidimport org.jxmpp.jid.Jidimport timber.log.Timberimport java.lang.reflect.UndeclaredThrowableExceptionimport java.util.*/** * Implements a Jabber `CallPeer`. * * @author Emil Ivov * @author Lyubomir Marinov * @author Boris Grozev * @author Eng Chong Meng */open class CallPeerJabberImpl(        peerAddress: FullJid,        owningCall: CallJabberImpl,) : MediaAwareCallPeer<CallJabberImpl, CallPeerMediaHandlerJabberImpl, ProtocolProviderServiceJabberImpl>(owningCall) {    /**     * If the call is cancelled before session-initiate is sent.     */    private var cancelled = false    /**     * Synchronization object for candidates available.     */    private val candSyncRoot = Any()    /**     * If the content-add does not contain candidates.     */    private var contentAddWithNoCands = false    /**     * If we have processed the session initiate.     */    private var sessionInitiateProcessed = false    /**     * If we have processed the session accept.     */    private var sessionAcceptProcessed = false    /**     * Synchronization object. Jingle transport-info processes are hold in waiting state until     * session-initiate is completed (notifyAll).     */    private val sessionInitiateSyncRoot = Any()    /**     * Synchronization object for SID.     */    private val sidSyncRoot = Any()    /**     * The current value of the 'senders' field of the audio content in the Jingle session with this     * `CallPeer`. `null` should be interpreted as 'both', which is the default in     * Jingle if the XML attribute is missing.     */    private var audioSenders: Senders? = Senders.none    /**     * The current value of the 'senders' field of the video content in the Jingle session with this     * `CallPeer`. `null` should be interpreted as 'both', which is the default in     * Jingle if the XML attribute is missing.     */    private var videoSenders: Senders? = Senders.none    /**     * Returns the service discovery information that we have for this peer.     *     * @return the service discovery information that we have for this peer.     */    /**     * Sets the service discovery information that we have for this peer.     *     * discoverInfo the discovery information that we have obtained for this peer.     */    /**     * Any discovery information that we have for this peer.     */    var discoveryInfo: DiscoverInfo? = null    private val mBasicTelephony = mPPS.getOperationSet(        OperationSetBasicTelephony::class.java) as OperationSetBasicTelephonyJabberImpl    /*     * Jingle Call Session get initialized when started a call initiator or     * in respond to an incoming call.     */    private var mJingleSession: JingleCallSessionImpl? = null    private val jutil = JingleUtil(mConnection)    /**     * Determines whether this peer initiated the session. Note that if this     * peer is the initiator of the session, then we are the responder!     *     * @return `true` if this peer initiated the session; `false`, otherwise     * (i.e. if _we_ initiated the session).     */    /**     * The indicator which determines whether this peer has initiated the session.     */    var isInitiator = false        private set    /**     * The jabber address of this peer     */    private var mPeerJid: FullJid    /**     * Returns the IQ ID of the Jingle session-initiate packet associated with this call.     *     * @return the IQ ID of the Jingle session-initiate packet associated with this call.     */    /**     * The [IQ] that created the session that this call represents.     */    var sessionIQ: Jingle? = null        private set    // contains a list of mediaType for session-initiate    private val contentMedias = ArrayList<String>()    /**     * Initiate a new call with the given remote `peerAddress`.     *     * peerAddress the Jabber address of the new call peer.     * owningCall the call that contains this call peer.     */    init {        mPeerJid = peerAddress        setMediaHandler(CallPeerMediaHandlerJabberImpl(this))    }    /**     * Creates a new call peer with address `peerAddress`, in response to an incoming call (session-initiate).     *     * owningCall the call that contains this call peer.     * sessionIQ The session-initiate `Jingle` which was received from `peerAddress`     * session current active jingle call session.     * and caused the creation of this `CallPeerJabberImpl`     */    constructor(owningCall: CallJabberImpl, sessionIQ: Jingle?, session: JingleCallSessionImpl) : this(session.remote,        owningCall) {        this.sessionIQ = sessionIQ        mJingleSession = session    }    /**     * Send a session-accept `Jingle` to this `CallPeer`     */    @Synchronized    @Throws(OperationFailedException::class)    fun answer() {        val jingleContents: Iterable<JingleContent>        val mediaHandler = mediaHandler        // cmeng: added to end ring tone when call from Conversations        setState(CallPeerState.CONNECTING_INCOMING_CALL)        try {            mediaHandler.transportManager.wrapupConnectivityEstablishment()            jingleContents = mediaHandler.generateSessionAccept()            for (c in jingleContents) {                setSenders(getMediaType(c), c.senders)            }        } catch (exc: Exception) {            Timber.e(exc, "Failed to answer an incoming call")            // send an error response            val reasonText = "Error: " + exc.message            setState(CallPeerState.FAILED, reasonText)            mJingleSession!!.terminateSessionAndUnregister(JingleReason.Reason.failed_application, reasonText)            return        }        // Send the session-accept first and start the stream later in case the        // media relay needs to see it before letting hole punching techniques through.        // Timber.w(new Exception("Create session accept"));        val response = jutil.createSessionAccept(sessionIQ, jingleContents)        try {            mConnection.sendStanza(response)        } catch (e1: NotConnectedException) {            throw OperationFailedException("Could not send session-accept",                OperationFailedException.REGISTRATION_REQUIRED, e1)        } catch (e1: InterruptedException) {            throw OperationFailedException("Could not send session-accept",                OperationFailedException.REGISTRATION_REQUIRED, e1)        }        try {            mediaHandler.start()        } catch (e: UndeclaredThrowableException) {            val exc = e.undeclaredThrowable            Timber.i(exc, "Failed to establish a connection")            // send an error response            val reasonText = "Error: " + exc.message            setState(CallPeerState.FAILED, reasonText)            mJingleSession!!.terminateSessionAndUnregister(JingleReason.Reason.general_error, reasonText)            return        }        // tell everyone we are connected so that the audio notifications would stop        setState(CallPeerState.CONNECTED)    }// cmeng: (2016/09/14) if (sid == null) means some implementation problem => cause smack exception.    /**     * Returns the session ID of the Jingle session associated with this call.     *     * @return the session ID of the Jingle session associated with this call.     */    val sid: String?        get() =// cmeng: (2016/09/14) if (sid == null) means some implementation problem => cause smack exception.            if (sessionIQ != null) sessionIQ!!.sid else null    /**     * Returns the session ID of the Jingle session associated with this call.     *     * @return the session ID of the Jingle session associated with this call.     */    val contentMedia: MutableList<String>        get() = contentMedias    /**     * End the call with this `CallPeer`. Depending on the state of the peer the method     * would send a cancel, success, or busy message and set the new state to DISCONNECTED.     *     * failed indicates if the hangup is following to a call failure or simply a disconnect     * reasonText the text, if any, to be set on the `JingleReason` as the value of its     * reasonExtension the `ExtensionElement`, if any, to be set on the `JingleReason`     * as the value of its `otherExtension` property; OR  or `JingleReason` to be sent unmodified     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun hangup(failed: Boolean, reasonTxt: String?, reasonExtension: Any?) {        var reasonText = reasonTxt        val prevPeerState = getState()        // do nothing if the call is already ended        if (CallPeerState.DISCONNECTED == prevPeerState || CallPeerState.FAILED == prevPeerState) {            Timber.d("Ignoring a request to hangup a call peer that is already DISCONNECTED")            return        }        // Timber.d("hangup call peer @state: %s", prevPeerState.getStateString());        // User hang up call, set reason code == NORMAL_CALL_CLEARING to stop missed call notification fired.        setState(if (failed) CallPeerState.FAILED else CallPeerState.DISCONNECTED, reasonText,            CallPeerChangeEvent.NORMAL_CALL_CLEARING)        var reason: JingleReason.Reason? = null        if (prevPeerState == CallPeerState.CONNECTED || CallPeerState.isOnHold(prevPeerState)) {            reason = JingleReason.Reason.success            reasonText = "Nice talking to you!"        }        else if (CallPeerState.CONNECTING == prevPeerState                || CallPeerState.CONNECTING_WITH_EARLY_MEDIA == prevPeerState                || CallPeerState.ALERTING_REMOTE_SIDE == prevPeerState) {            sid ?: synchronized(sidSyncRoot) {                // we cancelled the call too early because the sid is null (i.e. the                // session-initiate has not been created) and no need to send the session-terminate                cancelled = true                return            }            reason = JingleReason.Reason.cancel            reasonText = "Call Retract!"        }        else if (CallPeerState.INCOMING_CALL == prevPeerState) {            reason = JingleReason.Reason.busy        }        else if (CallPeerState.BUSY == prevPeerState || CallPeerState.FAILED == prevPeerState) {            // For FAILED and BUSY we only need to update CALL_STATUS as everything else has been done already.        }        else {            Timber.i("Could not determine call peer state!")        }        if (reason != null) {            val jingleReason = if (reasonExtension is JingleReason) {                reasonExtension            }            else {                JingleReason(reason, reasonText, reasonExtension as ExtensionElement?)            }            // Must wait for response before unregisterJingleSessionHandler()            mJingleSession!!.terminateSession(jingleReason)            mJingleSession!!.unregisterJingleSessionHandler()        }    }    /**     * Creates and sends a session-initiate [Jingle].     *     * sessionInitiateExtensions a collection of additional and optional `ExtensionElement`s     * to be added to the `session-initiate`;     * [Jingle] which is to initiate the session with this `CallPeerJabberImpl`     * sid The session-initiate sid, must be the same as in Jingle Message id if call is init from 'proceed'     * @throws OperationFailedException exception     */    @Synchronized    @Throws(OperationFailedException::class)    fun initiateSession(sessionInitiateExtensions: Iterable<ExtensionElement?>?, sid: String?) {        isInitiator = false        contentMedias.clear()        // Create the media description that we'd like to send to the other side.        val offer = mediaHandler.createContentList()        for (contentSI in offer) {            contentMedias.add(contentSI.name)        }        synchronized(sidSyncRoot) {            sessionIQ = jutil.createSessionInitiate(mPeerJid, sid, offer)            if (cancelled) {                // we cancelled the call too early so no need to send the session-initiate to peer                mediaHandler.transportManager.close()                return            }        }        if (sessionInitiateExtensions != null) {            for (sessionInitiateExtension in sessionInitiateExtensions) {                sessionIQ!!.addExtension(sessionInitiateExtension)            }        }        try {            // Only do it here, so it will get unregistered when caller cancel the call            mJingleSession = JingleCallSessionImpl(mConnection, mPeerJid, sid, mBasicTelephony)            mConnection.sendStanza(sessionIQ)            // Sending of JingleMessage retract not further required once session-initiate has started.            JingleMessageSessionImpl.setAllowSendRetract(false)        } catch (e: NotConnectedException) {            throw OperationFailedException(aTalkApp.getResString(R.string.service_gui_CREATE_CALL_FAILED),                OperationFailedException.REGISTRATION_REQUIRED)        } catch (e: InterruptedException) {            throw OperationFailedException(aTalkApp.getResString(R.string.service_gui_CREATE_CALL_FAILED),                OperationFailedException.REGISTRATION_REQUIRED)        }    }    /**     * Notifies this instance that a specific `ColibriConferenceIQ` has been received.     * This `CallPeerJabberImpl` uses the part of the information provided in the specified     * `conferenceIQ` which concerns it only.     *     * conferenceIQ the `ColibriConferenceIQ` which has been received     */    fun processColibriConferenceIQ(conferenceIQ: ColibriConferenceIQ) {        /*         * CallPeerJabberImpl does not itself/directly know the specifics related to the channels         * allocated on the Jitsi Videobridge server. The channels contain transport and         * media-related information so forward the notification to CallPeerMediaHandlerJabberImpl.         */        mediaHandler.processColibriConferenceIQ(conferenceIQ)    }    /**     * Processes the content-accept [Jingle].     *     * jingleCA The [Jingle] that contains content that remote peer has accepted     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun processContentAccept(jingleCA: Jingle) {        val contentList = jingleCA.contents        val mediaHandler = mediaHandler        try {            mediaHandler.transportManager.wrapupConnectivityEstablishment()            mediaHandler.processSessionAcceptContent(contentList)            for (c in contentList) setSenders(getMediaType(c), c.senders)        } catch (e: Exception) {            Timber.w(e, "Failed to process a content-accept")            // Send an error response.            val reasonText = "Error: " + e.message            setState(CallPeerState.FAILED, reasonText)            mJingleSession!!.terminateSessionAndUnregister(JingleReason.Reason.incompatible_parameters, reasonText)            return        }        mediaHandler.start()    }    /**     * Processes the content-add [Jingle].     *     * content The [Jingle] that contains content that remote peer wants to be added     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun processContentAdd(content: Jingle) {        val mediaHandler = mediaHandler        val contents = content.contents        var answerContents: Iterable<JingleContent>? = null        var contentIQ: Jingle?        var noCands = false        val oldVideoStream = mediaHandler.getStream(MediaType.VIDEO)        Timber.i("Looking for candidates in content-add.")        try {            if (!contentAddWithNoCands) {                mediaHandler.processOffer(contents)                // Jingle transport will not put candidate in session-initiate and content-add.                for (c in contents) {                    if (JingleUtils.getFirstCandidate(c, 1) == null) {                        contentAddWithNoCands = true                        noCands = true                    }                }            }            // if no candidates are present, launch a new Thread which will process and wait for the            // connectivity establishment (otherwise the existing thread will be blocked and thus            // cannot receive transport-info with candidates            if (noCands) {                object : Thread() {                    override fun run() {                        try {                            synchronized(candSyncRoot) {                                (candSyncRoot as Object).wait(1000)                                contentAddWithNoCands = false                            }                            processContentAdd(content)                        } catch (ex: InterruptedException) {                            ex.printStackTrace()                        } catch (ex: NotConnectedException) {                            ex.printStackTrace()                        }                    }                }.start()                Timber.i("No candidates found in content-add, started new thread.")                return            }            mediaHandler.transportManager.wrapupConnectivityEstablishment()            Timber.i("Wrapping up connectivity establishment")            answerContents = mediaHandler.generateSessionAccept()            contentIQ = null        } catch (e: Exception) {            Timber.w(e, "Exception occurred")            contentIQ = jutil.createContentReject(mPeerJid, sid, answerContents)        }        if (contentIQ == null) {            /* send content-accept */            contentIQ = jutil.createContentAccept(mPeerJid, sid, answerContents)            for (c in answerContents!!) setSenders(getMediaType(c), c.senders)        }        mConnection.sendStanza(contentIQ)        mediaHandler.start()        /*         * If a remote peer turns her video on in a conference which is hosted by the local peer and         * the local peer is not streaming her local video, re-invite the other remote peers to         * enable RTP translation.         */        if (oldVideoStream == null) {            val newVideoStream = mediaHandler.getStream(MediaType.VIDEO)            if (newVideoStream != null && mediaHandler.isRTPTranslationEnabled(MediaType.VIDEO)) {                try {                    getCall()!!.modifyVideoContent()                } catch (ofe: OperationFailedException) {                    Timber.e(ofe, "Failed to enable RTP translation")                }            }        }    }    /**     * Processes the content-modify [Jingle].     *     * content The [Jingle] that contains content that remote peer wants to be modified     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun processContentModify(content: Jingle) {        val ext = content.contents[0]        val mediaType = getMediaType(ext)        try {            val modify = ext.getFirstChildElement(RtpDescription::class.java) != null            mediaHandler.reinitContent(ext.name, ext, modify)            setSenders(mediaType, ext.senders)            if (MediaType.VIDEO == mediaType) getCall()!!.modifyVideoContent()        } catch (e: Exception) {            Timber.w(e, "Failed to process an incoming content-modify")            // Send an error response.            val reasonText = "Error: " + e.message            setState(CallPeerState.FAILED, reasonText)            mJingleSession!!.terminateSessionAndUnregister(JingleReason.Reason.incompatible_parameters, reasonText)        }    }    /**     * Processes the content-reject [Jingle].     *     * content The [Jingle]     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun processContentReject(content: Jingle) {        if (content.contents.isEmpty()) {            // send an error response;            val reasonText = "Error: content rejected"            setState(CallPeerState.FAILED, reasonText)            mJingleSession!!.terminateSessionAndUnregister(JingleReason.Reason.incompatible_parameters, reasonText)        }    }    /**     * Processes the content-remove [Jingle].     *     * content The [Jingle] that contains content that remote peer wants to be removed     */    fun processContentRemove(content: Jingle) {        val contents = content.contents        var videoContentRemoved = false        if (contents.isNotEmpty()) {            for (c in contents) {                mediaHandler.removeContent(c.name)                val mediaType = getMediaType(c)                setSenders(mediaType, Senders.none)                if (MediaType.VIDEO == mediaType) videoContentRemoved = true            }            /*             * TODO XEP-0166: Jingle says: If the content-remove results in zero content definitions             * for the session, the entity that receives the content-remove SHOULD send a             * session-terminate action to the other party (since a session with no content             * definitions is void).             */        }        if (videoContentRemoved) {            // removing of the video content might affect the other sessions in the call            try {                getCall()!!.modifyVideoContent()            } catch (e: Exception) {                Timber.w("Failed to update Jingle sessions")            }        }    }    /**     * Processes a session-accept [Jingle].     *     * jingleSA The session-accept [Jingle] to process.     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun processSessionAccept(jingleSA: Jingle) {        if (sessionAcceptProcessed) {            Timber.w("Ignore multiple session-accept received from: %s", this)            return        }        sessionIQ = jingleSA        /*         * Session-accept contentList request may contains both audio and video requests e.g.         * <content creator='initiator' name='audio'>         * <content creator='initiator' name='video' senders='both'>         */        val contentList = jingleSA.contents        try {            val transportManager = mediaHandler.transportManager                    ?: throw Exception("No available transport manager to process session-accept!")            sessionAcceptProcessed = true            transportManager.wrapupConnectivityEstablishment()            mediaHandler.processSessionAcceptContent(contentList)            for (c in contentList) {                setSenders(getMediaType(c), c.senders)            }        } catch (exc: Exception) {            Timber.w(exc, "Failed to process a session-accept")            // send an error response;            val reasonText = "Error: " + exc.message            setState(CallPeerState.FAILED, reasonText)            mJingleSession!!.terminateSessionAndUnregister(JingleReason.Reason.incompatible_parameters, reasonText)            return        }        // tell everyone we are connected so that the audio notifications would stop        setState(CallPeerState.CONNECTED)        mediaHandler.start()        /*         * If video was added to the call after we sent the session-initiate to this peer, it needs         * to be added to this peer's session with a content-add.         */        sendModifyVideoContent()    }    /**     * Handles the specified session `info` packet according to its content.     *     * info the [SessionInfo] that we just received.     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun processSessionInfo(info: SessionInfo) {        when (info.type) {            SessionInfoType.ringing -> setState(CallPeerState.ALERTING_REMOTE_SIDE)            SessionInfoType.hold -> {                mediaHandler.remotelyOnHold = true                reevalRemoteHoldStatus()            }            SessionInfoType.unhold, SessionInfoType.active -> {                mediaHandler.remotelyOnHold = false                reevalRemoteHoldStatus()            }            else -> Timber.w("Received SessionInfoExtensionElement of unknown type")        }    }    /**     * Processes the session initiation [Jingle] that we have received, passing its     * content to the media handler and then sends either a "session-info/ringing" or a     * "session-terminate" response.     *     * sessionInitIQ The [Jingle] that created the session that we are handling here.     */    @Synchronized    @Throws(NotConnectedException::class, InterruptedException::class)    fun processSessionInitiate(sessionInitIQ: Jingle) {        // Do initiate the session.        sessionIQ = sessionInitIQ        isInitiator = true        val recipient = sessionInitIQ.initiator        val sessionId = sessionInitIQ.sid        // This is the SDP offer that came from the initial session-initiate.        // Contrary to SIP, we are guaranteed to have content because        // XEP-0166 says: "A session consists of at least one content type at a time."        val offer = sessionInitIQ.contents        try {            mediaHandler.processOffer(offer)            var coin: CoinExtension? = null            for (ext in sessionInitIQ.extensions) {                if (ext.elementName == CoinExtension.ELEMENT) {                    coin = ext as CoinExtension                    break                }            }            /* Does the call peer acts as a conference focus ? */            if (coin != null) {                setConferenceFocus(coin.isFocus)            }        } catch (ex: Exception) {            Timber.w(ex, "Failed to process an incoming session initiate")            // send an error response;            val reasonText = "Error: " + ex.message            setState(CallPeerState.FAILED, reasonText)            mJingleSession!!.terminateSessionAndUnregister(JingleReason.Reason.incompatible_parameters, reasonText)            return        }        // If we do not get the info about the remote peer yet. Get it right now.        if (discoveryInfo === null) {            val calleeURI = sessionInitIQ.from            retrieveDiscoveryInfo(calleeURI)        }        // send a ringing response; cmeng??? what about auto-answer\        if (CallPeerState.DISCONNECTED != getState()) {            mConnection.sendStanza(jutil.createSessionInfo(recipient, sessionId, SessionInfoType.ringing))        }        // set flag to indicate that session-initiate process has completed.        synchronized(sessionInitiateSyncRoot) {            sessionInitiateProcessed = true            // cmeng - Importance: must notifyAll as there are multiple transport-info's on waiting            sessionInitiateSyncRoot.notifyAll()        }        // if this is a 3264 initiator, let's give them an early peek at our answer so that they could        // start ICE (SIP-2-Jingle gateways won't be able to send their candidates unless they have this)        val discoverInfo = discoveryInfo        if (discoverInfo !== null                && discoverInfo.containsFeature(ProtocolProviderServiceJabberImpl.URN_IETF_RFC_3264)) {            mConnection.sendStanza(jutil.createDescriptionInfo(                sessionInitIQ, mediaHandler.getLocalContentList()))        }        // process members if any        processSourceAdd(sessionInitIQ)    }    /**     * Puts this peer into a [CallPeerState.DISCONNECTED], indicating a reason to the user, if there is one.     *     * jingle the [Jingle] that's terminating our session.     */    fun processSessionTerminate(jingle: Jingle) {        var reasonStr = "Call ended by remote side."        val jingleReason = jingle.reason        if (jingleReason != null) {            val reason = jingleReason.asEnum()            if (reason != null) reasonStr += "\nReason: $reason."            val text = jingleReason.text            if (text != null) reasonStr += "\n$text"        }        setState(CallPeerState.DISCONNECTED, reasonStr)        mJingleSession!!.unregisterJingleSessionHandler()    }    /**     * Processes a specific "XEP-0251: Jingle Session Transfer" `transfer` stanza (extension).     *     * transfer the "XEP-0251: Jingle Session Transfer" transfer stanza (extension) to process     * @throws OperationFailedException if anything goes wrong while processing the specified     * `transfer` stanza (extension)     */    @Throws(OperationFailedException::class)    fun processTransfer(transfer: SdpTransfer, jingleIQ: Jingle) {        val calleeJid = transfer.to.asFullJidIfPossible()                ?: throw OperationFailedException("Session unattended transfer must contain a 'to' attribute value.",                    OperationFailedException.ILLEGAL_ARGUMENT)        val attendantJid = jingleIQ.from                ?: throw OperationFailedException("Session transfer source is unknown.",                    OperationFailedException.ILLEGAL_ARGUMENT)        // Checks if the transfer remote peer is contained by the roster of this account.        val roster = Roster.getInstanceFor(mConnection)        if (!roster.contains(calleeJid.asBareJid())) {            val failedMessage = "Transfer not possible:\nAccount roster does not contain transfer peer: $calleeJid"            Timber.w(failedMessage)            setState(CallPeerState.FAILED, failedMessage)            return        }        /*         * calleeTransfer content depends on unattended or attended transfer request         * <a href="https://xmpp.org/extensions/xep-0251.html#unattended">XEP-0251 ยง 2. Unattended Transfer</a>         * <a href="https://xmpp.org/extensions/xep-0251.html#attended ">XEP-0251 ยง 3. Attended Transfer</a>         * Attended call transfer sid must not be null         */        val calleeTransfer = if (transfer.sid != null) {            // Attended transfer; just forward the received transfer            transfer        }        else {            // Unattended transfer, must init the from attribute to attendant Jid            SdpTransfer.getBuilder().setFrom(attendantJid).build()        }        // Transfer jingle session-initiate must use new Sid; perform init JingleCallSessionImpl() in initiateSession        val calleeCall = CallJabberImpl(mBasicTelephony, JingleManager.randomId())        mBasicTelephony.createOutgoingCall(calleeCall, calleeJid, listOf(calleeTransfer))    }    /**     * Processes the offered remote `transport-info` [Jingle].     * The transport-info is used to exchange transport candidates for mediaHandler.     * cmeng: The wait control for session-accept is now handled at:     * OperationSetBasicTelephonyJabberImpl#processTransportInfo(CallPeerJabberImpl, Jingle)     *     * jingle containing the `transport-info` [Jingle] to be processed.     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun processOfferTransportInfo(jingle: Jingle) {        try {            // Wait (1000ms max) for session-accept to arrive before start processing any transport-info.            // content-accept is received 9 seconds after transport-info; so this method does not work            if (isInitiator) {                synchronized(sessionInitiateSyncRoot) {                    if (!sessionInitiateProcessed) {                        try {                            (sessionInitiateSyncRoot as Object).wait(10)                        } catch (ex: InterruptedException) {                            ex.printStackTrace()                        }                    }                }            }            val jingleContents = jingle.contents            val media = ArrayList<String>()            for (jingleContent in jingleContents) {                media.add(jingleContent.name)            }            Timber.d("### Processing Jingle (transport-info) for media: %s : %s", media, jingle.stanzaId)            mediaHandler.processTransportInfo(jingleContents)        } catch (ofe: OperationFailedException) {            Timber.w(ofe, "Failed to process an incoming transport-info")            // send an error response            val reasonText = "Error: " + ofe.message            setState(CallPeerState.FAILED, reasonText)            mJingleSession!!.terminateSessionAndUnregister(JingleReason.Reason.failed_transport, reasonText)            return        }        synchronized(candSyncRoot) { candSyncRoot.notifyAll() }    }    /**     * Puts the `CallPeer` represented by this instance on or off hold.     *     * onHold `true` to have the `CallPeer` put on hold; `false`, otherwise     * @throws OperationFailedException if we fail to construct or send the INVITE request putting the     * remote side on/off hold.     */    @Throws(OperationFailedException::class)    fun putOnHold(onHold: Boolean) {        val mediaHandler = mediaHandler        mediaHandler.isLocallyOnHold = onHold        val type: SessionInfoType        if (onHold) type = SessionInfoType.hold        else {            type = SessionInfoType.unhold            mediaHandler.reinitAllContents()        }        // we are now on hold and need to realize this before potentially        // spoiling it all with an exception while sending the packet.        reevalLocalHoldStatus()        val onHoldIQ = jutil.createSessionInfo(mPeerJid, sid, type)        try {            mConnection.sendStanza(onHoldIQ)        } catch (e: NotConnectedException) {            throw OperationFailedException("Could not send session info",                OperationFailedException.REGISTRATION_REQUIRED, e)        } catch (e: InterruptedException) {            throw OperationFailedException("Could not send session info",                OperationFailedException.REGISTRATION_REQUIRED, e)        }    }    /**     * Sends a `content` message to reflect changes in the setup such as the local peer/user     * becoming a conference focus.     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun sendCoinSessionInfo() {        val sessionInfo = jutil.createSessionInfo(mPeerJid, sid)        val coinExt = CoinExtension.getBuilder()            .setFocus(getCall()!!.isConferenceFocus)            .build()        sessionInfo.addExtension(coinExt)        mConnection.sendStanza(sessionInfo)    }    /**     * Returns the `MediaDirection` that should be set for the content of type `mediaType`     * in the Jingle session for this `CallPeer`. If we are the focus of a conference and are doing     * RTP translation, takes into account the other `CallPeer`s in the `Call`.     *     * mediaType the `MediaType` for which to return the `MediaDirection`.     * Only use by MediaType.VIDEO currently.     * @return the `MediaDirection` that should be used for the content of type     * `mediaType` in the Jingle session for this `CallPeer`.     */    private fun getDirectionForJingle(mediaType: MediaType): MediaDirection {        var direction = MediaDirection.INACTIVE        var senders = getSenders(mediaType)        //  cmeng (20210321): Approach aborted due to complexity and NewReceiveStreamEvent not alway gets triggered:        // If we are streaming the media, the direction should allow sending; device orientation change does not        // constitute to a content-modify, see https://xmpp.org/extensions/xep-0166.html#def-action-content-modify//        boolean orientationChange = (PreviewStream.previewPortrait != aTalkApp.isPortrait);//        if ((MediaType.AUDIO == mediaType && mediaHandler.isLocalAudioTransmissionEnabled())//                || ((MediaType.VIDEO == mediaType) && (isLocalVideoStreaming()//                || (orientationChange && (senders == Senders.both//                || (initiator && senders == Senders.responder)//                || (!initiator && senders == Senders.initiator))))))        if ((MediaType.AUDIO == mediaType && mediaHandler.isLocalAudioTransmissionEnabled)                || (MediaType.VIDEO == mediaType && isLocalVideoStreaming))            direction = direction.or(MediaDirection.SENDONLY)        // If we are receiving media from this CallPeer, the direction should allow receiving        if (senders == Senders.both                || (isInitiator && senders == Senders.initiator)                || (!isInitiator && senders == Senders.responder))            direction = direction.or(MediaDirection.RECVONLY)        // If we are the focus of a conference, and we are receiving media from        // another CallPeer in the same Call, the direction should allow sending        val call = getCall()        if (call != null && call.isConferenceFocus) {            for (peer in call.getCallPeerList()) {                if (peer != this) {                    senders = peer.getSenders(mediaType)                    if (senders == Senders.both                            || (peer.isInitiator && senders == Senders.initiator)                            || (!peer.isInitiator && senders == Senders.responder)) {                        direction = direction.or(MediaDirection.SENDONLY)                        break                    }                }            }        }        // Timber.w("Media Sender direction %s <= %s || (%s && %s) %s", direction, isLocalVideoStreaming(), orientationChange, senders, initiator);        return direction    }    /**     * Send, if necessary, a jingle `content` message to reflect change in the video setup.     * Whether the jingle session should have a video content, and if so, the value of the     * `senders` field is determined based on whether we are streaming local video and, if we     * are the focus of a conference, on the other peers in the conference. The message can be     * content-modify if video content exists (and the `senders` field changes), content-add     * or content-remove.     *     * @return `true` if a jingle `content` message was sent.     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun sendModifyVideoContent(): Boolean {        val direction = getDirectionForJingle(MediaType.VIDEO)        val remoteContent = mediaHandler.getLocalContent(MediaType.VIDEO.toString())        if (remoteContent == null) {            return if (direction == MediaDirection.INACTIVE) {                // no video content, none needed                false            }            else { // no remote video and local video added                if (getState() == CallPeerState.CONNECTED) {                    Timber.i("Adding video content for %s", this)                    sendAddVideoContent()                    return true                }                false            }        }        else {            if (direction == MediaDirection.INACTIVE) {                sendRemoveVideoContent()                return true            }        }        var senders = getSenders(MediaType.VIDEO)        if (senders == null) senders = Senders.both        var newSenders = Senders.none        when {            MediaDirection.SENDRECV == direction -> newSenders = Senders.both            MediaDirection.RECVONLY == direction -> newSenders = if (isInitiator) Senders.initiator else Senders.responder            MediaDirection.SENDONLY == direction -> newSenders = if (isInitiator) Senders.responder else Senders.initiator        }        /*         * Send Content-Modify         * cmeng (2016/9/14) only send content-modify if there is a change in own video streaming state         */        if (newSenders != senders) {            Timber.i("Sending content modify, senders: %s -> %s", senders, newSenders)            val remoteContentName = remoteContent.name            val content = JingleContent.getBuilder()                .setCreator(remoteContent.creator)                .setName(remoteContentName)                .setSenders(newSenders)                .build()            // cmeng: must update local videoSenders for content-modify            setSenders(MediaType.VIDEO, newSenders)            val contentIQ = jutil.createContentModify(mPeerJid, sid, content)            mConnection.sendStanza(contentIQ)            try {                mediaHandler.reinitContent(remoteContentName, content, false)                mediaHandler.start()            } catch (e: Exception) {                Timber.w(e, "Exception occurred during media reinitialization")            }        }        return newSenders != senders    }    /**     * Send a `content` message to reflect change in the video setup (start or stop).     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun sendModifyVideoResolutionContent() {        val mediaHandler = mediaHandler        val remoteContent = mediaHandler.getRemoteContent(MediaType.VIDEO.toString())        Timber.i("send modify-content to change resolution")        // send content-modify with RTP description        // create content list with resolution        val content = try {            mediaHandler.createContentForMedia(MediaType.VIDEO)        } catch (e: Exception) {            Timber.w(e, "Failed to gather content for video type")            return        }        // if we are only receiving video senders is null        val senders = remoteContent!!.senders        if (senders != null) content!!.senders = senders        val contentIQ = jutil.createContentModify(mPeerJid, sid, content)        mConnection.sendStanza(contentIQ)        try {            mediaHandler.reinitContent(remoteContent.name, content!!, false)            mediaHandler.start()        } catch (e: Exception) {            Timber.w(e, "Exception occurred when media reinitialization")        }    }    /**     * Send a `content-add` to add video setup.     */    @Throws(NotConnectedException::class, InterruptedException::class)    private fun sendAddVideoContent() {        val contents: List<JingleContent?>?        try {            contents = mediaHandler.createContentList(MediaType.VIDEO)            // cmeng (20220613): must update local videoSenders for content-add            setSenders(MediaType.VIDEO, Senders.initiator)        } catch (exc: Exception) {            Timber.w(exc, "Failed to gather content for video type")            return        }        val contentIQ = jutil.createContentAdd(mPeerJid, sid, contents)        mConnection.sendStanza(contentIQ)    }    /**     * Send a `content-remove` to remove video setup.     */    @Throws(NotConnectedException::class, InterruptedException::class)    private fun sendRemoveVideoContent() {        val remoteContent = mediaHandler.getRemoteContent(MediaType.VIDEO.toString())                ?: return        val remoteContentName = remoteContent.name        val content = JingleContent.getBuilder()            .setCreator(remoteContent.creator)            .setName(remoteContentName)            .setSenders(remoteContent.senders)            .build()        val contentIQ = jutil.createContentRemove(mPeerJid, sid, listOf(content))        mConnection.sendStanza(contentIQ)        mediaHandler.removeContent(remoteContentName)        setSenders(MediaType.VIDEO, Senders.none)    }    /**     * Sends local candidate addresses from the local peer to the remote peer using the     * `transport-info` [Jingle].     *     * contents the local candidate addresses to be sent from the local peer to the remote peer using     * the `transport-info` [Jingle]     */    @Throws(NotConnectedException::class, InterruptedException::class)    fun sendTransportInfo(contents: Iterable<JingleContent?>?) {        // if the call is canceled or disconnected, do not start sending candidates in transport-info.        if (cancelled || CallPeerState.DISCONNECTED == getState()) return        val transportInfo = jutil.createTransportInfo(mPeerJid, sid, contents)        val collector = mConnection.createStanzaCollectorAndSend(transportInfo)        try {            collector.nextResult<Stanza>()        } finally {            collector.cancel()        }    }    override fun setState(newState: CallPeerState, reason: String?, reasonCode: Int) {        val oldState = getState()        try {            /*             * We need to dispose of the transport manager before the 'call' field is set to null,             * because if Jitsi Videobridge is in use, it (the call) is needed in order to expire             * the Videobridge channels.             */            if (CallPeerState.DISCONNECTED == newState || CallPeerState.FAILED == newState) {                mediaHandler.transportManager.close()            }        } finally {            super.setState(newState, reason, reasonCode)        }        if (CallPeerState.isOnHold(oldState) && CallPeerState.CONNECTED == newState) {            try {                getCall()!!.modifyVideoContent()            } catch (ofe: OperationFailedException) {                Timber.e("Failed to update call video state after 'hold' status removed for %s", this)            }        }    }    /**     * Transfer (in the sense of call transfer) this `CallPeer` to a specific callee address     * which may optionally be participating in an active `Call`.     *     * to the address of the callee to transfer this `CallPeer` to     * sid the Jingle session ID of the active `Call` between the local peer and the     * callee in the case of attended transfer; `null` in the case of unattended transfer     * @throws OperationFailedException if something goes wrong     */    @Throws(OperationFailedException::class)    fun transfer(to: Jid?, sid: String?) {        // Attended transfer needs all the attrs to have values.        val transferBuilder = SdpTransfer.getBuilder().setTo(to)        if (sid != null) {            transferBuilder                .setFrom(mPPS.ourJID)                .setSid(sid)            // Puts on hold the callPeer before making the attended transfer.            val callPeer = mBasicTelephony.getActiveCallPeer(sid)            if (callPeer != null) {                if (!CallPeerState.isOnHold(callPeer.getState())) {                    callPeer.putOnHold(true)                }            }            if (!CallPeerState.isOnHold(getState())) {                putOnHold(true)            }        }        val transferSessionInfo = jutil.createSessionInfo(mPeerJid, this.sid)        transferSessionInfo.addExtension(transferBuilder.build())        try {            val collector = mConnection.createStanzaCollectorAndSend(transferSessionInfo)            try {                collector.nextResultOrThrow<Stanza>()            } finally {                collector.cancel()            }        } catch (e: NotConnectedException) {            throw OperationFailedException("Could not send transfer session info",                OperationFailedException.REGISTRATION_REQUIRED, e)        } catch (e: InterruptedException) {            throw OperationFailedException("Could not send transfer session info",                OperationFailedException.REGISTRATION_REQUIRED, e)        } catch (e1: XMPPErrorException) {            // Log the failed transfer call and notify the user.            throw OperationFailedException("Remote peer does not support call 'transfer'. "                    + e1.stanzaError, OperationFailedException.ILLEGAL_ARGUMENT)        } catch (e1: NoResponseException) {            // Log the failed transfer call and notify the user.            throw OperationFailedException("No response to 'transfer' request.",                OperationFailedException.ILLEGAL_ARGUMENT)        }        val message = aTalkApp.getResString(R.string.gui_call_transfer_msg,            if (sid == null) "Unattended" else "Attended", to)        try {            // Implements the SIP behavior: once the transfer is accepted, the current call is closed.            hangup(false, message,                JingleReason(JingleReason.Reason.success, message, SdpTransferred.getBuilder().build()))        } catch (e: NotConnectedException) {            throw OperationFailedException("Could not send transfer", 0, e)        } catch (e: InterruptedException) {            throw OperationFailedException("Could not send transfer", 0, e)        }    }    /**     * {@inheritDoc}     */    override fun getEntity(): String? {        return getAddress()    }    /**     * {@inheritDoc}     *     * In Jingle there isn't an actual "direction" parameter. We use the `senders` field to     * calculate the direction.     */    override fun getDirection(mediaType: MediaType?): MediaDirection {        return when (getSenders(mediaType)) {            Senders.none -> {                MediaDirection.INACTIVE            }            Senders.both -> {                MediaDirection.SENDRECV            }            Senders.initiator -> {                if (isInitiator) MediaDirection.RECVONLY else MediaDirection.SENDONLY            }            else -> { // senders == Senders.responder                if (isInitiator) MediaDirection.SENDONLY else MediaDirection.RECVONLY            }        }    }    override fun getProtocolProvider(): ProtocolProviderServiceJabberImpl {        return mPPS    }    /**     * Gets the current value of the `senders` field of the content with name     * `mediaType` in the Jingle session with this `CallPeer`.     *     * mediaType the `MediaType` for which to get the current value of the `senders` field.     * @return the current value of the `senders` field of the content with name     * `mediaType` in the Jingle session with this `CallPeer`.     */    fun getSenders(mediaType: MediaType?): Senders? {        return when (mediaType) {            MediaType.AUDIO -> audioSenders            MediaType.VIDEO -> videoSenders            else -> Senders.none        }    }    /**     * Set the current value of the `senders` field of the content with name     * `mediaType` in the Jingle session with this `CallPeer`     *     * mediaType the `MediaType` for which to get the current value of the `senders` field.     * senders the value to set.     */    private fun setSenders(mediaType: MediaType?, senders: Senders?) {        when (mediaType) {            MediaType.AUDIO -> audioSenders = senders            MediaType.VIDEO -> videoSenders = senders            else -> throw IllegalArgumentException("mediaType")        }    }    /**     * Gets the `MediaType` of `content`. If `content` does not have a     * `description` child and therefore not `MediaType` can be associated with it,     * tries to take the `MediaType` from the session's already established contents with the     * same name as `content`     *     * content the `JingleContent` for which to get the `MediaType`     * @return the `MediaType` of `content`.     */    fun getMediaType(content: JingleContent): MediaType? {        val contentName = content.name ?: return null        var mediaType = JingleUtils.getMediaType(content)        if (mediaType == null) {            for (m in MediaType.values()) {                var sessionContent = mediaHandler.getRemoteContent(m.toString())                if (sessionContent == null) sessionContent = mediaHandler.getLocalContent(m.toString())                if (sessionContent != null && contentName == sessionContent.name) {                    mediaType = m                    break                }            }        }        return mediaType    }    /**     * Processes the source-add [Jingle] action used in Jitsi-Meet.     * For now processing only audio, as we use single ssrc for audio and     * using multiple ssrcs for video. ConferenceMember currently support single     * ssrc for audio and video and adding multiple ssrcs will need a large refactor.     *     * content The [Jingle] that contains content that remote     * peer wants to be added     */    fun processSourceAdd(content: Jingle) {        for (c in content.contents) {            // we are parsing only audio            if (MediaType.AUDIO != JingleUtils.getMediaType(c)) {                continue            }            val rtpDesc = c.getFirstChildElement(RtpDescription::class.java)            // for (MediaPresenceExtension.Source src : rtpDesc.getChildExtensionsOfType(MediaPresenceExtension.Source.class)) {            for (src in rtpDesc.getChildElements(SdpSource::class.java)) {                val ssrcInfo = src.getFirstChildElement(SSRCInfoExtension::class.java)                        ?: continue                val owner = ssrcInfo.owner ?: continue                var member = findConferenceMemberByAddress(owner)                if (member == null) {                    member = AbstractConferenceMember(this, owner.toString())                    addConferenceMember(member)                }                member.setAudioSsrc(src.ssrc)            }        }    }    /**     * Processes the source-remove [Jingle] action used in Jitsi-Meet.     * For now processing only audio, as we use single ssrc for audio and     * using multiple ssrcs for video. ConferenceMember currently support single     * ssrc for audio and video and adding multiple ssrcs will need a large refactor.     *     * content The [Jingle] that contains content that remote peer wants to be removed     */    fun processSourceRemove(content: Jingle) {        for (c in content.contents) {            // we are parsing only audio            if (MediaType.AUDIO != JingleUtils.getMediaType(c)) {                continue            }            val rtpDesc = c.getFirstChildElement(RtpDescription::class.java)            for (src in rtpDesc.getChildElements(SdpSource::class.java)) {                val ssrcInfo = src.getFirstChildElement(SSRCInfoExtension::class.java)                        ?: continue                val owner = ssrcInfo.owner ?: continue                val member = findConferenceMemberByAddress(owner)                if (member != null) removeConferenceMember(member)            }        }    }    /**     * Finds `ConferenceMember` by its address.     *     * address the address to look for     * @return `ConferenceMember` with `address` or null if not found.     */    private fun findConferenceMemberByAddress(address: Jid): AbstractConferenceMember? {        for (member in getConferenceMembers()) {            if (member.getAddress() == address.toString()) {                return member as AbstractConferenceMember            }        }        return null    }    /**     * Returns a String locator for that peer.     *     * @return the peer's address or phone number.     */    override fun getAddress(): String {        return mPeerJid.toString()    }    override fun getPeerJid(): Jid? {        return mPeerJid    }    /**     * Returns the contact corresponding to this peer or null if no particular contact has been associated.     *     * @return the `Contact` corresponding to this peer or null if no particular contact has been associated.     */    override fun getContact(): Contact? {        val presence = mPPS.getOperationSet(OperationSetPresence::class.java)        return presence?.findContactByJid(mPeerJid)    }    /**     * Returns a human readable name representing this peer.     *     * @return a String containing a name for that peer.     */    override fun getDisplayName(): String? {        if (getCall() != null) {            val contact = getContact()            if (contact != null) return contact.displayName        }        return mPeerJid.toString()    }    /**     * Returns full URI of the address.     *     * @return full URI of the address     */    override fun getURI(): String? {        return "xmpp:$mPeerJid"    }    /**     * Retrieves the DiscoverInfo for a given peer identified by its URI.     *     * calleeURI The URI of the call peer.     */    private fun retrieveDiscoveryInfo(calleeURI: Jid) {        try {            val discoveryInfo = mPPS.discoveryManager!!.discoverInfo(calleeURI)            if (discoveryInfo !== null)                this.discoveryInfo = discoveryInfo        } catch (xmppex: XMPPException) {            Timber.w(xmppex, "Could not retrieve info for %s", calleeURI)        } catch (xmppex: InterruptedException) {            Timber.w(xmppex, "Could not retrieve info for %s", calleeURI)        } catch (xmppex: NoResponseException) {            Timber.w(xmppex, "Could not retrieve info for %s", calleeURI)        } catch (xmppex: NotConnectedException) {            Timber.w(xmppex, "Could not retrieve info for %s", calleeURI)        }    }    /**     * Specifies the address, phone number, or other protocol specific     * identifier that represents this call peer. This method is to be     * used by service users and MUST NOT be called by the implementation.     *     * address The address of this call peer.     */    fun setAddress(address: FullJid) {        if (!mPeerJid.equals(address)) {            val oldAddress = getAddress()            mPeerJid = address            fireCallPeerChangeEvent(CallPeerChangeEvent.CALL_PEER_ADDRESS_CHANGE, oldAddress, address)        }    }    /**     * Returns the IQ StanzaId of the Jingle session-initiate associated with this call.     *     * @return the IQ StanzaId of the Jingle session-initiate associated with this call.     */    val jingleIQStanzaId: String?        get() = if (sessionIQ != null) sessionIQ!!.stanzaId else null}